<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EventHorizon.mtg â€” CMS</title>

    <!-- Favicon per silenziare 404 (opzionale) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><text y=%2214%22 font-size=%2214%22>ðŸŒ€</text></svg>">

    <!-- Decap CMS (CDN) -->
    <script defer src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>

    <!--
      Auth bridge robusto:
      - Intercetta token in hash/query (legacy "authorization:github:success:" o access_token/token)
      - Se la pagina gira in un POPUP ed Ã¨ presente un opener, invia il messaggio all'opener e chiude il popup
      - Altrimenti, forza la route su "#/login" e re-dispatch SOLO {token} (con piccoli retry) per farlo consumare da Decap
      - Pulisce lâ€™URL
    -->
    <script defer>
      (function () {
        var LOGIN_ROUTE = "#/login";

        function ensureLoginRouteThen(fn) {
          var target = window.location.pathname + window.location.search.replace(/^\?$/, "") + LOGIN_ROUTE;
          if (window.location.hash !== LOGIN_ROUTE) {
            history.replaceState(null, "", target);
            setTimeout(fn, 50); // lascia il tempo al router Decap di montarsi
          } else {
            fn();
          }
        }

        // Invia SOLO {token} in formato legacy, con piccoli retry per evitare race
        function dispatchLegacyTokenOnlyToSelf(data) {
          var safe = { token: data && data.token ? data.token : null };
          if (!safe.token) return;
          var msg = "authorization:github:success:" + JSON.stringify(safe);
          var tries = 0, max = 3;
          (function tick() {
            window.postMessage(msg, "*");
            if (++tries < max) setTimeout(tick, 150);
          })();
        }

        // Invia SOLO {token} all'opener (se esiste), con un minimo di tolleranza
        function postToOpenerAndMaybeClose(data) {
          var safe = { token: data && data.token ? data.token : null };
          if (!safe.token) return false;
          var msg = "authorization:github:success:" + JSON.stringify(safe);
          try {
            if (window.opener && !window.opener.closed) {
              // invia 2 volte a distanza ravvicinata per massima compatibilitÃ 
              window.opener.postMessage(msg, "*");
              setTimeout(function(){ try { window.opener.postMessage(msg, "*"); } catch(_){} }, 60);
              // prova a chiudere il popup (non blocca se il browser lo impedisce)
              setTimeout(function(){ try { window.close(); } catch(_){} }, 120);
              return true;
            }
          } catch(_) {}
          return false;
        }

        function parseAuthFromHashOrQuery() {
          var h = window.location.hash || "";
          var q = window.location.search || "";

          // 1) Legacy prefix nel hash (popup fallback del Worker)
          if (h && h !== "#" && h !== "#/" && h !== LOGIN_ROUTE) {
            var hash = h.charAt(0) === "#" ? h.slice(1) : h;

            var legacyPrefix = "authorization:github:success:";
            if (hash.indexOf(legacyPrefix) === 0) {
              try {
                // Alcuni worker non encodano, altri sÃ¬; decodeURIComponent Ã¨ tollerante
                var raw = decodeURIComponent(hash.slice(legacyPrefix.length));
                var data = JSON.parse(raw);
                return { token: data && data.token ? data.token : null };
              } catch (e) {}
            }

            // 1b) Variante: access_token/token nel hash
            try {
              var paramsH = new URLSearchParams(hash);
              var tokenH = paramsH.get("access_token") || paramsH.get("token");
              if (tokenH) return { token: tokenH };
            } catch (_) {}
          }

          // 2) Variante: access_token/token nella query string
          if (q && q.length > 1) {
            try {
              var paramsQ = new URLSearchParams(q.charAt(0) === "?" ? q.slice(1) : q);
              var tokenQ = paramsQ.get("access_token") || paramsQ.get("token");
              if (tokenQ) return { token: tokenQ };
            } catch (_) {}
          }
          return null;
        }

        function cleanupUrl(keepLogin) {
          var hash = keepLogin ? LOGIN_ROUTE : "#/";
          var clean = window.location.pathname + window.location.search.replace(/^\?$/, "") + hash;
          history.replaceState(null, "", clean);
        }

        function relayFromUrlIfPresent() {
          var data = parseAuthFromHashOrQuery();
          if (!data) return;

          // Caso 1: siamo nel POPUP (opener esistente) â†’ invia all'opener e chiudi
          if (window.opener && !window.opener.closed) {
            var ok = postToOpenerAndMaybeClose(data);
            // Pulizia URL del popup (comunque)
            cleanupUrl(true);
            if (ok) return; // missione compiuta, il main riceverÃ  il token
          }

          // Caso 2: finestra principale (o nessun opener) â†’ consumalo localmente
          ensureLoginRouteThen(function () {
            dispatchLegacyTokenOnlyToSelf(data);
            cleanupUrl(true);
          });
        }

        // Avvio relay al load (Decap giÃ  caricato grazie a defer)
        if (document.readyState === "complete") {
          relayFromUrlIfPresent();
        } else {
          window.addEventListener("load", relayFromUrlIfPresent);
        }

        // Se il popup OAuth invia il messaggio in diretta al MAIN, porta su #/login e rilancia SOLO {token} con retry
        window.addEventListener("message", function (ev) {
          if (typeof ev.data === "string" && ev.data.indexOf("authorization:github:success:") === 0) {
            try {
              var raw = ev.data.slice("authorization:github:success:".length);
              var obj = JSON.parse(raw || "{}");
              var data = { token: obj && obj.token ? obj.token : null };
              if (!data.token) return;
              ensureLoginRouteThen(function () {
                setTimeout(function () { dispatchLegacyTokenOnlyToSelf(data); }, 30);
              });
            } catch (_) {}
          }
        });
      })();
    </script>
  </head>
  <body>
    <div id="nc-root"></div>
  </body>
</html>
