<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Admin · Mini Editor (Hugo + GitHub)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="stylesheet" href="admin.css">
<script src="vendor/marked.min.js"></script>

</head>
<body>
<div class="wrap">
  <div id="buildNotice" class="notice hidden"><span class="spinner"></span><span class="msg">Build in corso…</span></div>
  <header>
    <div class="row" id="authRow">
      <button id="loginBtn" class="btn primary">Login con GitHub</button>
      <button id="logoutBtn" class="btn" hidden>Logout</button>
      <span id="who" class="status"></span>
    </div>
    <div class="row hidden" id="viewRow">
      <button id="viewItemsBtn" class="btn btn-tab active">Archivio</button>
      <button id="viewArticlesBtn" class="btn btn-tab">Articoli</button>
    </div>
    <div class="row hidden" id="actionsRow">
      <button id="newBtn" class="btn">Nuovo item</button>
      <button id="saveBtn" class="btn primary">Salva</button>
      <button id="multiBtn" class="btn">Seleziona multipli</button>
      <button id="deleteSelectedBtn" class="btn danger hidden" disabled>Elimina selezionati</button>
      <span id="saveStatus" class="status"></span>
    </div>
    <div class="row hidden" id="articleActionsRow">
      <button id="newArticleBtn" class="btn">Nuovo articolo</button>
      <button id="saveArticleBtn" class="btn primary">Salva articolo</button>
      <button id="deleteArticleBtn" class="btn danger" disabled>Elimina articolo</button>
      <span id="articleStatus" class="status"></span>
    </div>
  </header>

  <div id="lockedOverlay" class="card login-guard">
    <strong>Accesso richiesto</strong>
    <p class="muted">Effettua il login con GitHub per utilizzare l'editor.</p>
  </div>

  <div id="adminMain" class="hidden">
    <div id="itemsSection" class="grid hidden">
      <div class="card">
        <div class="row justify-between mb-8">
          <div>
            <strong>Archivio - Items</strong>
            <div class="muted">folder: <code>data/archive/items</code> - branch: <code>main</code></div>
          </div>
          <button id="reloadBtn" class="btn">Reload</button>
        </div>
        <div id="list" class="list"></div>
      </div>

      <div class="card">
        <div class="two mt-8">
          <div>
            <label>Data</label>
            <input id="f_date" type="date" />
          </div>
          <div>
            <label>Titolo</label>
            <input id="f_title" type="text" placeholder="Titolo" />
          </div>
        </div>

        <div class="two mt-8">
          <div>
            <label>Slug (kebab-case)</label>
            <input id="f_slug" type="text" placeholder="es. nuova-carta-xyz" />
          </div>
          <div>
            <label>Tipo</label>
            <input id="f_kind" type="text" placeholder="video | content" />
          </div>
        </div>

        <div class="two mt-8">
          <div>
            <label>Overline</label>
            <input id="f_overline" type="text" />
          </div>
          <div>
            <label>Autore</label>
            <input id="f_author" type="text" />
          </div>
        </div>

        <div class="two mt-8">
          <div>
            <label>ID</label>
            <input id="f_id" type="text" placeholder="opzionale (fallback: slug)" />
          </div>
          <div>
            <label>Thumbnail</label>
            <div class="row align-center gap-8">
              <input id="f_thumb" type="text" placeholder="/images/thumbs/... oppure URL" />
              <input id="uploadThumb" type="file" accept="image/*" hidden />
              <button id="btnUploadThumb" class="btn">Carica</button>
              <button id="btnBrowseThumb" class="btn">Sfoglia</button>
            </div>
            <div id="thumbBrowser" class="asset-browser hidden"></div>
          </div>
        </div>

        <div class="mt-8">
          <label>Descrizione</label>
          <textarea id="f_desc" class="textarea--sm" placeholder="Testo descrizione (opzionale)"></textarea>
        </div>

        <div class="two" style="margin-top:8px">
          <div>
            <label>Tag (separati da virgola)</label>
            <input id="f_tags" type="text" placeholder="es. commander, edh, guide" />
            <div id="tagsSaved" class="tags-saved mt-8"></div>
          </div>
          <div class="switch-row">
            <div class="switch-pair">
              <label for="f_draft">Bozza</label>
              <input id="f_draft" type="checkbox" />
            </div>
            <div class="switch-pair">
              <label for="f_updated">Aggiornato</label>
              <input id="f_updated" type="datetime-local" />
            </div>
          </div>
        </div>

        <div class="mt-8">
          <label>Immagine Card (home)</label>
          <div class="row align-center gap-8">
            <input id="f_card" type="text" placeholder="/images/cards/... oppure URL" />
            <input id="uploadCard" type="file" accept="image/*" hidden />
            <button id="btnUploadCard" class="btn">Carica</button>
            <button id="btnBrowseCard" class="btn">Sfoglia</button>
          </div>
          <div id="cardBrowser" class="asset-browser hidden"></div>
        </div>

        <div class="mt-8">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
            <label>Link</label>
            <button id="addLinkBtn" class="btn">Aggiungi link</button>
          </div>
          <div id="linksList" class="links-list"></div>
          <div class="muted">Campi: Label, URL, Classe, Ordine, Primario</div>
        </div>

        <div style="margin-top:8px">
          <label>YAML grezzo (avanzato)</label>
          <textarea id="f_raw" placeholder="# qui vedi/modifichi l'intero YAML"></textarea>
          <div class="muted">Puoi editare i campi sopra o direttamente il YAML. Al salvataggio unifichiamo.</div>
        </div>

        <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
          <span id="fileInfo" class="pill">-</span>
          <button id="deleteBtn" class="btn danger">Elimina</button>
        </div>
      </div>
    </div>

    <div id="articlesSection" class="grid hidden">
      <div class="card">
        <div class="row justify-between mb-8">
          <div>
            <strong>Elenco Articoli</strong>
            <div class="muted">folder: <code>content/article</code> - branch: <code>main</code></div>
          </div>
          <button id="reloadArticlesBtn" class="btn">Reload</button>
        </div>
        <div class="row mb-8" style="gap:8px;">
          <input type="text" id="articleSearchInput" placeholder="🔍 Cerca articoli..." style="flex:1;min-width:0;" />
          <select id="articleFilterDraft" style="width:auto;">
            <option value="all">Tutti</option>
            <option value="published">Pubblicati</option>
            <option value="drafts">Solo bozze</option>
          </select>
        </div>
        <div id="articleList" class="list"></div>
      </div>

      <div class="card">
        <div class="mt-8">
          <label>Template</label>
          <select id="a_template" style="width:100%;">
            <option value="">Nessun template (vuoto)</option>
            <option value="tutorial">Tutorial / Guida</option>
            <option value="news">News / Aggiornamento</option>
            <option value="review">Recensione / Review</option>
            <option value="deck">Deck Tech / Lista</option>
          </select>
        </div>

        <div class="two mt-8">
          <div>
            <label>Titolo</label>
            <input id="a_title" type="text" placeholder="Titolo articolo" />
          </div>
          <div>
            <label>Slug</label>
            <input id="a_slug" type="text" placeholder="es. nuovo-articolo" />
          </div>
        </div>

        <div class="two mt-8">
          <div>
            <label>Data</label>
            <input id="a_date" type="datetime-local" />
          </div>
          <div class="switch-pair">
            <label for="a_draft">Bozza</label>
            <input id="a_draft" type="checkbox" />
          </div>
        </div>

        <div class="mt-8">
          <label>Descrizione (SEO)</label>
          <textarea id="a_description" class="textarea--sm" placeholder="Breve descrizione (120-160 caratteri consigliati)"></textarea>
          <div class="muted" style="display:flex;justify-content:space-between;margin-top:4px;font-size:13px;">
            <span id="a_descCount">0 caratteri</span>
            <span id="a_descHint" style="color:var(--muted);"></span>
          </div>
        </div>

        <div class="mt-8">
          <label>Tag (separati da virgola)</label>
          <input id="a_tags" type="text" placeholder="es. mtg, gameplay" />
        </div>

        <div class="mt-8">
          <label>Cover</label>
          <div class="row align-center gap-8">
            <input id="a_cover" type="text" placeholder="images/articles/..." />
            <input id="a_coverUpload" type="file" accept="image/*" hidden />
            <button id="a_btnUploadCover" class="btn">Upload cover</button>
            <button id="a_btnBrowseCover" class="btn">Sfoglia</button>
          </div>
          <div id="a_coverPreview" style="margin-top:8px;display:none;">
            <img id="a_coverPreviewImg" src="" alt="Cover preview" style="max-width:300px;max-height:200px;border-radius:8px;border:1px solid var(--border);" />
          </div>
          <div id="a_coverBrowser" class="asset-browser hidden"></div>
        </div>

        <div class="mt-8">
          <label>Immagini per Contenuto</label>
          <div class="row align-center gap-8">
            <input id="a_contentImageUpload" type="file" accept="image/*" multiple hidden />
            <button id="a_btnUploadContentImage" class="btn">Carica immagini</button>
            <span class="muted" style="font-size:13px;">Upload multiplo in static/images/articles/{slug}/</span>
          </div>
          <div id="a_contentImagesList" class="asset-grid mt-8" style="display:none;"></div>
        </div>

        <div class="mt-8">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <label>Contenuto (Markdown)</label>
            <button id="a_togglePreview" class="btn" type="button">Mostra Preview</button>
          </div>

          <div class="markdown-toolbar" style="display:flex;gap:4px;margin:8px 0;flex-wrap:wrap;">
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('**', '**')" title="Bold">
              <strong>B</strong>
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('*', '*')" title="Italic">
              <em>I</em>
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('## ', '')" title="Titolo H2">
              H2
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('### ', '')" title="Titolo H3">
              H3
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('[', '](url)')" title="Link">
              Link
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('![alt](', ')')" title="Immagine">
              Img
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('\`\`\`\n', '\n\`\`\`')" title="Blocco codice">
              Code
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('- ', '')" title="Lista">
              Lista
            </button>
            <button type="button" class="btn" style="padding:4px 8px;font-size:13px;" onclick="insertMarkdown('> ', '')" title="Citazione">
              Quote
            </button>
          </div>

          <div class="editor-wrapper" style="display:grid;grid-template-columns:1fr;gap:16px;">
            <textarea id="a_body" class="textarea--lg" placeholder="Contenuto dell'articolo"></textarea>
            <div id="a_preview" class="markdown-preview" style="border:1px solid var(--border-color, #ddd);padding:16px;min-height:400px;display:none;overflow-y:auto;background:#fff;border-radius:4px;"></div>
          </div>

          <div class="muted" style="display:flex;justify-content:space-between;margin-top:4px;">
            <span id="a_charCount">0 caratteri, 0 parole</span>
            <span id="a_readTime">~0 min di lettura</span>
          </div>
        </div>

        <div class="mt-8" style="display:flex;gap:8px;align-items:center">
          <span id="articleFileInfo" class="pill">-</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- YAML parser -->
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js" integrity="sha256-Rdw90D3AegZwWiwpibjH9wkBPwS9U4bjJ51ORH8H69c=" crossorigin="anonymous"></script>
<script>
/* ====== CONFIGURAZIONE ====== */
let OWNER = "eventhorizon-mtg";
let REPO  = "eventhorizon-mtg.github.io";
let BRANCH = "main";  // Branch principale (corretto da "test")
let FOLDER = "data/archive/items";
let EXT    = "yml";
let WORKER_BASE = "https://eventhorizon-oauth.cetriolo-mtg.workers.dev";
let AUTH_ENDPOINT = "auth";
let APP_ID = ""; // Client ID (dal config)
let WORKER_ORIGIN = new URL(WORKER_BASE).origin;
let MEDIA_FOLDER = "static/uploads";
let PUBLIC_FOLDER = "/uploads";
// Destinazioni dedicate per immagini usate dal sito
let CARDS_DIR    = "static/images/cards";
let CARDS_PUBLIC = "/images/cards";
let THUMBS_DIR   = "static/images/thumbs";
let THUMBS_PUBLIC= "/images/thumbs";
let ARTICLES_DIR = "content/article";
let ARTICLES_EXT = "md";
let ARTICLES_MEDIA_DIR = "static/images/articles";
let ARTICLES_MEDIA_PUBLIC = "images/articles";

async function loadConfig() {
  try {
    const res = await fetch("config.yml", { cache: "no-store" });
    if (!res.ok) return; // fallback ai default hardcoded
    const txt = await res.text();
    const cfg = jsyaml.load(txt) || {};
    if (cfg.backend) {
      const repoStr = cfg.backend.repo || ""; // es. owner/name
      if (repoStr.includes("/")) {
        const [owner, repoName] = repoStr.split("/", 2);
        if (owner) OWNER = owner;
        if (repoName) REPO = repoName;
      }
      if (cfg.backend.branch) BRANCH = cfg.backend.branch;
      if (cfg.backend.base_url) {
        WORKER_BASE = cfg.backend.base_url.replace(/\/$/, "");
        WORKER_ORIGIN = new URL(WORKER_BASE).origin;
      }
      if (cfg.backend.auth_endpoint) AUTH_ENDPOINT = cfg.backend.auth_endpoint;
      if (cfg.backend.app_id) APP_ID = cfg.backend.app_id;
    }
    const coll = (cfg.collections || []).find(c => c.name === "archive_items");
    if (coll) {
      if (coll.folder) FOLDER = coll.folder.replace(/\/$/, "");
      if (coll.extension) EXT = String(coll.extension).replace(/^\./, "");
      if (cfg.media_folder) MEDIA_FOLDER = String(cfg.media_folder).replace(/\/$/, "");
      if (cfg.public_folder) PUBLIC_FOLDER = String(cfg.public_folder).replace(/\/$/, "");
      // Se il config definisce opzioni per kind, trasforma input in select
      const kindFieldCfg = (coll.fields || []).find(f => f.name === "kind");
      const kindOpts = kindFieldCfg && Array.isArray(kindFieldCfg.options) ? kindFieldCfg.options : null;
      if (kindOpts && kindOpts.length) {
        const old = byId("f_kind");
        if (old) {
          const sel = document.createElement("select");
          sel.id = "f_kind";
          for (const o of kindOpts) {
            const opt = document.createElement('option');
            opt.value = String(o.value ?? '');
            opt.textContent = String(o.label ?? '');
            sel.appendChild(opt);
          }
          old.parentNode.replaceChild(sel, old);
        }
      }
    }
  } catch (e) {
    console.warn("Config non caricato:", e);
  }
}

/* ====== STATO ====== */
let TOKEN = (typeof sessionStorage!=="undefined" && sessionStorage.getItem("gh_token"))
  || (typeof localStorage!=="undefined" && localStorage.getItem("gh_token"))
  || "";
let OAUTH_POPUP = null;
let DEPLOY_LOCK = false;
const DEPLOY_LOCK_KEY = 'admin_deploy_lock';
const DEPLOY_LOCK_TIMEOUT = 180000; // 3 minuti max per deploy
let MULTI_MODE = false;
const SELECTED_ITEMS = new Map(); // path -> { sha }
const ARTICLES_CACHE = new Map();
let CURRENT = null; // {path, sha, yaml}
let CURRENT_VIEW = 'items';
let ARTICLE_CURRENT = null; // {path, sha, front, body}
const ARTICLE_PENDING = { cover: null };

/* ====== UTILS ====== */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const gh = async (url, opts={}, retryCount=0) => {
  const maxRetries = 3;
  const baseDelay = 1000; // 1 secondo

  const response = await fetch(url, {
    ...opts,
    headers: {
      "Accept":"application/vnd.github+json",
      "X-GitHub-Api-Version":"2022-11-28",
      "Authorization": TOKEN ? `token ${TOKEN}` : undefined,
      "Content-Type": opts.body ? "application/json" : undefined
    }
  });

  // Intercetta 401 Unauthorized (token scaduto o invalido)
  if (response.status === 401 && TOKEN) {
    console.warn('GitHub API 401: Token scaduto o invalido');

    // Mostra messaggio e richiedi re-autenticazione
    const reauth = confirm(
      'La tua sessione è scaduta o il token non è più valido.\n\n' +
      'Clicca OK per effettuare nuovamente il login con GitHub.'
    );

    if (reauth) {
      // Pulisci token e ricarica per forzare login
      try { sessionStorage.removeItem('gh_token'); } catch(_) {}
      try { localStorage.removeItem('gh_token'); } catch(_) {}
      TOKEN = '';
      window.location.reload();
    } else {
      // Utente ha cancellato: mostra overlay login
      setWho(null);
    }

    return response;
  }

  // Intercetta 403 Rate Limit (GitHub API limit exceeded)
  if (response.status === 403 && retryCount < maxRetries) {
    const rateLimitRemaining = response.headers.get('x-ratelimit-remaining');
    const rateLimitReset = response.headers.get('x-ratelimit-reset');

    // Check se è veramente rate limit o altro 403
    if (rateLimitRemaining === '0' || response.headers.get('x-ratelimit-limit')) {
      console.warn(`GitHub API Rate Limit raggiunto. Retry ${retryCount + 1}/${maxRetries}...`);

      // Calcola delay: exponential backoff
      const delay = baseDelay * Math.pow(2, retryCount);

      // Se conosciamo il reset time, usiamo quello
      let waitTime = delay;
      if (rateLimitReset) {
        const resetTime = parseInt(rateLimitReset) * 1000;
        const now = Date.now();
        const timeUntilReset = resetTime - now;

        // Se reset è tra meno di 60 secondi, aspetta fino a reset + 1 sec
        if (timeUntilReset > 0 && timeUntilReset < 60000) {
          waitTime = timeUntilReset + 1000;
        }
      }

      // Mostra notifica all'utente
      const maxWait = 30000; // Max 30 secondi di attesa
      if (waitTime > maxWait) waitTime = maxWait;

      console.log(`Attesa ${Math.floor(waitTime/1000)}s prima di riprovare...`);

      await sleep(waitTime);

      // Retry ricorsivo
      return gh(url, opts, retryCount + 1);
    }
  }

  // Intercetta errori di rete temporanei (retry solo per GET)
  if (!response.ok && retryCount < maxRetries && (!opts.method || opts.method === 'GET')) {
    if (response.status >= 500 || response.status === 0) {
      console.warn(`GitHub API errore ${response.status}. Retry ${retryCount + 1}/${maxRetries}...`);

      const delay = baseDelay * Math.pow(2, retryCount);
      await sleep(delay);

      return gh(url, opts, retryCount + 1);
    }
  }

  return response;
};
const b64 = {
  enc: (s) => {
    const bytes = new TextEncoder().encode(String(s));
    let bin = ""; bytes.forEach(b => bin += String.fromCharCode(b));
    return btoa(bin);
  },
  dec: (b) => {
    const bin = atob(b || "");
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }
};

async function fetchSiteVersion(){
  const u = new URL('/', window.location.origin);
  u.searchParams.set('t', String(Date.now()));
  const res = await fetch(u.toString(), { cache: 'reload', credentials:'same-origin' });
  if (!res.ok) throw new Error('fetchSiteVersion HTTP '+res.status);
  const html = await res.text();
  const m = html.match(/data-archive-ver="([^"]*)"/i);
  return m ? m[1] : '';
}
async function waitForNewBuild(prev, timeoutMs=60000, intervalMs=2000){
  const end = Date.now() + timeoutMs;
  while (Date.now() < end) {
    try {
      const v = await fetchSiteVersion();
      if (v && v !== prev) return true;
    } catch(_) {}
    await sleep(intervalMs);
  }
  return false;
}

function toPublicUrlFromPath(path){
  try{
    const mf = MEDIA_FOLDER.replace(/\\/g,'/');
    if (path.startsWith(mf)){
      const rel = path.slice(mf.length).replace(/^\//,'');
      return `${PUBLIC_FOLDER}/${rel}`.replace(/\/+/g,'/');
    }
  }catch(_){ }
  return `/${path.replace(/^static\//,'')}`;
}

async function listImages(rootPath, depth=2){
  const out = [];
  async function walk(p, d){
    const u = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}?ref=${encodeURIComponent(BRANCH)}`;
    const r = await gh(u);
    if (!r.ok) return;
    const arr = await r.json();
    for (const it of arr){
      if (it.type === 'file' && /\.(png|jpe?g|webp|gif|avif|svg)$/i.test(it.name)){
        out.push({ path: it.path, name: it.name, publicUrl: toPublicUrlFromPath(it.path) });
      } else if (it.type === 'dir' && d > 0){
        await walk(it.path, d-1);
      }
    }
  }
  await walk(rootPath, depth);
  return out;
}

// Cache reset helper: invalida SW caches (se presenti) e ricarica risorse chiave
async function resetSiteCaches(){
  try{
    if ('caches' in window) {
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }
  } catch(_) {}
  const stamp = Date.now();
  try{
    await Promise.allSettled([
      fetch(`/archive/list.json?v=${stamp}`, { cache: 'reload', credentials: 'same-origin' }),
      fetch(`/?cb=${stamp}`,               { cache: 'reload', credentials: 'same-origin' }),
      fetch(`/archive/?cb=${stamp}`,       { cache: 'reload', credentials: 'same-origin' })
    ]);
  } catch(_) {}
  try { localStorage.setItem('site_cache_bust', String(stamp)); } catch(_) {}
  try {
    if (typeof loadList === 'function' && TOKEN) {
      await loadList();
    }
    if (typeof loadArticlesList === 'function' && TOKEN) {
      await loadArticlesList();
    }
  } catch(_){ }
}

// Legge una 'versione' dalla home per rilevare la nuova build
 

async function getPagesLatest(){
  const url = `https://api.github.com/repos/${OWNER}/${REPO}/pages/builds/latest`;
  const r = await gh(url);
  if (!r.ok) throw new Error('pages latest '+r.status);
  return r.json();
}
async function monitorDeployAndReload(){
  showNotice('Build/deploy avviato…');
  const start = Date.now();
  let autoReloaded = false;
  const autoReloadTimer = setTimeout(() => {
    autoReloaded = true;
    try { updateNotice('Aggiornamento automatico in corso...'); } catch(_){ }
    hideNotice();
    const url = new URL(window.location.href);
    url.searchParams.set('t', String(Date.now()));
    window.location.replace(url.toString());
  }, 40000);
  const cancelAutoReload = () => { if (!autoReloaded) clearTimeout(autoReloadTimer); };
  let baseLatest = null;
  try { baseLatest = await getPagesLatest(); } catch(_) {}
  const baseTime = baseLatest ? (Date.parse(baseLatest.updated_at||'') || 0) : 0;
  const prevVersion = await fetchSiteVersion().catch(()=> '');

  // Se l'endpoint Pages non Ã¨ disponibile, fallback diretto su versione
  if (!baseTime && !baseLatest) {
    updateNotice('Attesa nuova versione del sito…');
    const ok = await waitForNewBuild(prevVersion, 90000, 2000).catch(()=>false);
    cancelAutoReload();
    hideNotice();
    return ok;
  }

  const deadline = Date.now() + 180000; // 3 minuti
  while (Date.now() < deadline) {
    let status = 'in attesa…';
    try {
      const latest = await getPagesLatest();
      const t = Date.parse(latest.updated_at||'') || 0;
      const changed = t > baseTime;
      status = String(latest.status || 'processing');
      if (changed && /built/i.test(status)) {
        updateNotice('Build completata, finalizzo deploy…');
        const ok = await waitForNewBuild(prevVersion, 30000, 2000).catch(()=>false);
        cancelAutoReload();
        hideNotice();
        return ok;
      }
      if (changed && /error/i.test(status)) {
        cancelAutoReload();
        hideNotice();
        alert('Build GitHub Pages fallita. Controlla i log di Pages/Actions.');
        return false;
      }
    } catch(_) { /* ignora e riprova */ }
    const secs = Math.floor((Date.now()-start)/1000);
    updateNotice(`Stato build: ${status} — ${secs}s`);
    await sleep(2000);
  }
  cancelAutoReload();
  hideNotice();
  return false;
}

function renderAssetBrowser(container, items, targetInput){
  container.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.className = 'asset-grid';
  for (const it of items){
    const a = document.createElement('div');
    a.className = 'asset';
    const img = document.createElement('img');
    img.src = String(it.publicUrl || '');
    img.alt = String(it.name || '');
    const meta = document.createElement('small');
    meta.className = 'meta';
    meta.textContent = String(it.name || '');
    a.appendChild(img);
    a.appendChild(meta);
    a.onclick = () => { targetInput.value = String(it.publicUrl || ''); container.classList.add('hidden'); };
    wrap.appendChild(a);
  }
  container.appendChild(wrap);
  container.classList.remove('hidden');
}
const byId = id => document.getElementById(id);
const kebab = s => String(s||"").toLowerCase().trim()
  .replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"");
// Escaping helpers to reduce XSS risk where innerHTML is used
function escHtml(s){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/\"/g,'&quot;')
    .replace(/'/g,'&#39;');
}
function escAttr(s){ return escHtml(s); }

/* ====== UI HOOKS ====== */
  const listEl = byId("list");
  const saveStatus = byId("saveStatus");
  const fileInfo = byId("fileInfo");
  const actionsRow = byId("actionsRow");
  const articleActionsRow = byId("articleActionsRow");
  const viewRow = byId("viewRow");
  const viewItemsBtn = byId("viewItemsBtn");
  const viewArticlesBtn = byId("viewArticlesBtn");
  const reloadBtn = byId("reloadBtn");
  if (reloadBtn) reloadBtn.onclick = () => loadList();
  const uploadThumbInput = byId("uploadThumb");
  const btnUploadThumb = byId("btnUploadThumb");
  const btnBrowseThumb = byId("btnBrowseThumb");
  const thumbBrowser = byId("thumbBrowser");
  const fThumb = byId("f_thumb");
  const uploadCardInput = byId("uploadCard");
  const btnUploadCard = byId("btnUploadCard");
  const btnBrowseCard = byId("btnBrowseCard");
  const cardBrowser = byId("cardBrowser");
  const fCard = byId("f_card");
  const multiBtn = byId("multiBtn");
  const deleteSelectedBtn = byId("deleteSelectedBtn");
  const adminMain = byId("adminMain");
  const itemsSection = byId("itemsSection");
  const articlesSection = byId("articlesSection");
  const articleStatus = byId("articleStatus");
  const articleList = byId("articleList");
  const articleFileInfo = byId("articleFileInfo");
  const reloadArticlesBtn = byId("reloadArticlesBtn");
  if (reloadArticlesBtn) reloadArticlesBtn.onclick = () => loadArticlesList();

  // Ricerca e filtro articoli
  const articleSearchInput = byId('articleSearchInput');
  const articleFilterDraft = byId('articleFilterDraft');

  if (articleSearchInput) {
    articleSearchInput.addEventListener('input', debounce(applyArticleFilters, 300));
  }

  if (articleFilterDraft) {
    articleFilterDraft.addEventListener('change', applyArticleFilters);
  }
  const newArticleBtn = byId("newArticleBtn");
  const saveArticleBtn = byId("saveArticleBtn");
  const deleteArticleBtn = byId("deleteArticleBtn");
  const aTitle = byId("a_title");
  const aSlug = byId("a_slug");
  const aDate = byId("a_date");
  const aDraft = byId("a_draft");
  const aDescription = byId("a_description");
  const aTags = byId("a_tags");
  const aCover = byId("a_cover");
  const aCoverUpload = byId("a_coverUpload");
  const aBtnUploadCover = byId("a_btnUploadCover");
  const aBtnBrowseCover = byId("a_btnBrowseCover");
  const aCoverBrowser = byId("a_coverBrowser");
  const aBody = byId("a_body");
  const aCoverPreview = byId("a_coverPreview");
  const aCoverPreviewImg = byId("a_coverPreviewImg");
  const aTemplate = byId("a_template");

  // Preview cover image quando cambia URL
  if (aCover && aCoverPreview && aCoverPreviewImg) {
    const updateCoverPreview = () => {
      const url = aCover.value.trim();
      if (url && /\.(jpg|jpeg|png|gif|webp|avif|svg)$/i.test(url)) {
        aCoverPreviewImg.src = url.startsWith('http') ? url : `/${url.replace(/^\//, '')}`;
        aCoverPreview.style.display = 'block';
        aCoverPreviewImg.onerror = () => {
          aCoverPreview.style.display = 'none';
        };
      } else {
        aCoverPreview.style.display = 'none';
      }
    };

    aCover.addEventListener('input', debounce(updateCoverPreview, 500));
    aCover.addEventListener('blur', updateCoverPreview);
  }

  // SEO Stats per descrizione
  const descCount = byId('a_descCount');
  const descHint = byId('a_descHint');

  if (aDescription && descCount && descHint) {
    const updateDescStats = () => {
      const len = aDescription.value.length;
      descCount.textContent = `${len} caratteri`;

      if (len === 0) {
        descHint.textContent = '⚠️ Descrizione mancante';
        descHint.style.color = 'var(--warn)';
      } else if (len < 120) {
        descHint.textContent = 'Troppo corta per SEO';
        descHint.style.color = 'var(--warn)';
      } else if (len > 160) {
        descHint.textContent = 'Troppo lunga, verrà troncata';
        descHint.style.color = 'var(--danger)';
      } else {
        descHint.textContent = '✓ Lunghezza ottimale';
        descHint.style.color = '#4ade80';
      }
    };

    aDescription.addEventListener('input', updateDescStats);
    updateDescStats();
  }

  // Template articoli
  const ARTICLE_TEMPLATES = {
    tutorial: {
      title: 'Guida: [Titolo Tutorial]',
      body: `# Introduzione

Breve introduzione al topic di questa guida.

## Requisiti

- Requisito 1
- Requisito 2
- Requisito 3

## Passo 1: [Nome Passo]

Descrizione dettagliata del primo passo.

## Passo 2: [Nome Passo]

Descrizione dettagliata del secondo passo.

## Conclusioni

Riassunto di ciò che è stato imparato.

---
*Hai domande? Lascia un commento!*`
    },
    news: {
      title: 'News: [Titolo Notizia]',
      body: `# [Titolo Principale]

**Data:** [Inserisci data evento]

## Cosa è successo?

Descrizione della notizia principale.

## Dettagli

- Punto chiave 1
- Punto chiave 2
- Punto chiave 3

## Implicazioni

Come questa notizia impatta la community/metagame.

---
*Fonte:* [Link fonte se applicabile]`
    },
    review: {
      title: 'Recensione: [Nome Carta/Prodotto]',
      body: `# Recensione: [Nome]

## Panoramica

Descrizione generale di cosa stiamo recensendo.

## Pro

- ✅ Vantaggio 1
- ✅ Vantaggio 2
- ✅ Vantaggio 3

## Contro

- ❌ Svantaggio 1
- ❌ Svantaggio 2

## Valutazione

**Voto:** [X/10]

## Conclusioni

Riassunto finale e raccomandazioni.`
    },
    deck: {
      title: 'Deck Tech: [Nome Deck]',
      body: `# Deck Tech: [Nome Deck]

## Strategia

Descrizione della strategia principale del deck.

## Decklist

### Comandante
- 1x [Nome Comandante]

### Creature ([XX])
- Lista creature

### Instant ([XX])
- Lista instant

### Sorcery ([XX])
- Lista sorcery

### Artifact ([XX])
- Lista artifact

### Enchantment ([XX])
- Lista enchantment

### Land ([XX])
- Lista terre

## Combo Chiave

Descrizione delle combo principali.

## Matchup

- **VS Aggro:** Come giocare
- **VS Control:** Come giocare
- **VS Combo:** Come giocare

## Budget Alternative

Opzioni più economiche per le carte costose.`
    }
  };

  if (aTemplate && aBody) {
    aTemplate.addEventListener('change', () => {
      const tpl = ARTICLE_TEMPLATES[aTemplate.value];
      if (!tpl) return;

      if (aBody.value && !confirm('Sovrascrivere il contenuto attuale con il template?')) {
        aTemplate.value = '';
        return;
      }

      if (aTitle && !aTitle.value) aTitle.value = tpl.title;
      if (aBody) aBody.value = tpl.body;

      updateCharCount();
      updateMarkdownPreview();
      updateArticleStatus('✓ Template applicato');
      aTemplate.value = '';
    });
  }

  function toggleLockOnButton(id, state){
    const btn = byId(id);
    if (!btn) return;
    if (state) {
      if (btn.getAttribute('data-lock-active') === '1') return;
      btn.setAttribute('data-lock-prev', btn.disabled ? '1' : '0');
      btn.disabled = true;
      btn.setAttribute('data-lock-active', '1');
      btn.setAttribute('aria-busy', 'true');
    } else if (btn.getAttribute('data-lock-active') === '1') {
      const prev = btn.getAttribute('data-lock-prev') === '1';
      btn.disabled = prev;
      btn.removeAttribute('data-lock-active');
      btn.removeAttribute('data-lock-prev');
      btn.removeAttribute('aria-busy');
    }
  }

  function updateDeployStatus(message){
    if (saveStatus) saveStatus.textContent = message || '';
  }

  function updateArticleStatus(message){
    if (articleStatus) articleStatus.textContent = message || '';
  }

  function setDeployLock(state, message){
    DEPLOY_LOCK = !!state;

    if (state) {
      // Acquisisce lock in localStorage con timestamp
      try {
        const lockData = {
          timestamp: Date.now(),
          message: message || 'Deploy in corso'
        };
        localStorage.setItem(DEPLOY_LOCK_KEY, JSON.stringify(lockData));
      } catch(e) {
        console.warn('Impossibile impostare deploy lock in localStorage:', e);
      }
    } else {
      // Rilascia lock
      try {
        localStorage.removeItem(DEPLOY_LOCK_KEY);
      } catch(e) {
        console.warn('Impossibile rimuovere deploy lock da localStorage:', e);
      }
    }

    ['saveBtn','deleteBtn','newBtn','deleteSelectedBtn','multiBtn','saveArticleBtn','deleteArticleBtn','newArticleBtn','reloadArticlesBtn','reloadBtn'].forEach(id => toggleLockOnButton(id, state));
    if (typeof message === 'string') updateDeployStatus(message);
    if (!state) updateSelectionStatus();
  }

  function isDeployLocked(){
    // Check lock in memoria
    if (DEPLOY_LOCK) return true;

    // Check lock in localStorage (persiste tra reload)
    try {
      const lockStr = localStorage.getItem(DEPLOY_LOCK_KEY);
      if (!lockStr) return false;

      const lockData = JSON.parse(lockStr);
      const age = Date.now() - lockData.timestamp;

      // Se lock è più vecchio del timeout, consideralo scaduto e rimuovilo
      if (age > DEPLOY_LOCK_TIMEOUT) {
        localStorage.removeItem(DEPLOY_LOCK_KEY);
        return false;
      }

      // Lock valido
      return true;
    } catch(e) {
      // Errore parsing, rimuovi lock corrotto
      try { localStorage.removeItem(DEPLOY_LOCK_KEY); } catch(_) {}
      return false;
    }
  }

  // Cleanup lock scaduti al boot
  function cleanupExpiredLocks() {
    try {
      const lockStr = localStorage.getItem(DEPLOY_LOCK_KEY);
      if (!lockStr) return;

      const lockData = JSON.parse(lockStr);
      const age = Date.now() - lockData.timestamp;

      if (age > DEPLOY_LOCK_TIMEOUT) {
        localStorage.removeItem(DEPLOY_LOCK_KEY);
        console.log('Rimosso deploy lock scaduto (età: ' + Math.floor(age/1000) + 's)');
      }
    } catch(e) {
      try { localStorage.removeItem(DEPLOY_LOCK_KEY); } catch(_) {}
    }
  }

  function updateSelectionStatus(){
    const count = SELECTED_ITEMS.size;
    const delBtn = byId('deleteSelectedBtn');
    if (delBtn) {
      delBtn.classList.toggle('hidden', !MULTI_MODE);
      delBtn.disabled = !MULTI_MODE || count === 0 || DEPLOY_LOCK;
      delBtn.textContent = count ? `Elimina selezionati (${count})` : 'Elimina selezionati';
    }
    const multiBtn = byId('multiBtn');
    if (multiBtn) multiBtn.textContent = MULTI_MODE ? 'Annulla selezione multipla' : 'Seleziona multipli';
    const statusEl = byId('saveStatus');
    if (!statusEl) return;
    if (CURRENT_VIEW !== 'items') {
      if (statusEl.dataset.selectionStatus === '1') {
        delete statusEl.dataset.selectionStatus;
        if (!DEPLOY_LOCK) statusEl.textContent = '';
      }
      return;
    }
    if (MULTI_MODE) {
      statusEl.dataset.selectionStatus = '1';
      statusEl.textContent = count ? `${count} elemento/i selezionati` : 'Seleziona elementi da eliminare';
    } else if (statusEl.dataset.selectionStatus === '1') {
      delete statusEl.dataset.selectionStatus;
      if (!DEPLOY_LOCK) statusEl.textContent = '';
    }
  }

  function setMultiMode(on, opts={}){
    const target = !!on;
    if (target === MULTI_MODE && !opts.force) {
      if (!target && opts.resetSelection) SELECTED_ITEMS.clear();
      updateSelectionStatus();
      return;
    }
    MULTI_MODE = target;
    if (!MULTI_MODE || opts.resetSelection) SELECTED_ITEMS.clear();
    updateSelectionStatus();
    if (!opts.skipReload && TOKEN) {
      loadList().catch(()=>{});
    }
  }

  function toggleSelection(path, sha, isSelected, el){
    if (isSelected) SELECTED_ITEMS.set(path, { sha });
    else SELECTED_ITEMS.delete(path);
    if (el) el.classList.toggle('is-selected', isSelected);
    updateSelectionStatus();
  }

  async function ensureContentSha(path, knownSha){
    if (knownSha) return knownSha;
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}?ref=${encodeURIComponent(BRANCH)}`;
    const r = await gh(url);
    if (!r.ok) {
      const t = await r.text().catch(()=>String(r.status));
      throw new Error(`Impossibile ottenere SHA per ${path}: ${r.status} - ${t}`);
    }
    const j = await r.json();
    return j.sha;
  }

  async function deleteContent(path, sha){
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`;
    const body = { message: `chore(admin): delete ${path}`, sha, branch: BRANCH };
    const r = await gh(url, { method:"DELETE", body: JSON.stringify(body) });
    if (!r.ok) {
      const t = await r.text().catch(()=>String(r.status));
      throw new Error(`Errore eliminazione ${path}: ${r.status} - ${t}`);
    }
  }

  function setView(view, opts={}){
    const target = view === 'articles' ? 'articles' : 'items';
    const previous = CURRENT_VIEW;
    const changed = previous !== target || !!opts.force;
    CURRENT_VIEW = target;

    if (itemsSection) itemsSection.classList.toggle('hidden', target !== 'items');
    if (articlesSection) articlesSection.classList.toggle('hidden', target !== 'articles');
    if (actionsRow) actionsRow.classList.toggle('hidden', !TOKEN || target !== 'items');
    if (articleActionsRow) articleActionsRow.classList.toggle('hidden', !TOKEN || target !== 'articles');
    if (viewRow) viewRow.classList.toggle('hidden', !TOKEN);
    if (adminMain) adminMain.classList.toggle('hidden', !TOKEN);
    if (viewItemsBtn) viewItemsBtn.classList.toggle('active', target === 'items');
    if (viewArticlesBtn) viewArticlesBtn.classList.toggle('active', target === 'articles');

    if (target === 'articles') {
      setMultiMode(false, { skipReload: true, resetSelection: true, force: true });
    }

    if (!TOKEN) return;
    if (!changed || opts.skipLoad) return;

    if (target === 'items') {
      loadList().catch(()=>{});
    } else {
      loadArticlesList().catch(()=>{});
    }
  }

  function setAuthState(isAuthed){
    const authed = !!isAuthed;
    if (!authed) setDeployLock(false);
    if (!authed) setMultiMode(false, { skipReload: true, resetSelection: true, force: true });

    const loginBtn = byId('loginBtn');
    if (loginBtn) {
      loginBtn.hidden = authed;
      loginBtn.disabled = authed;
    }
    const logoutBtn = byId('logoutBtn');
    if (logoutBtn) {
      logoutBtn.hidden = !authed;
      logoutBtn.disabled = !authed;
    }

    if (viewRow) viewRow.classList.toggle('hidden', !authed);
    if (actionsRow) actionsRow.classList.toggle('hidden', !authed || CURRENT_VIEW !== 'items');
    if (articleActionsRow) articleActionsRow.classList.toggle('hidden', !authed || CURRENT_VIEW !== 'articles');
    const overlay = byId('lockedOverlay');
    if (overlay) overlay.classList.toggle('hidden', authed);
    if (adminMain) adminMain.classList.toggle('hidden', !authed);
    if (itemsSection) itemsSection.classList.toggle('hidden', !authed || CURRENT_VIEW !== 'items');
    if (articlesSection) articlesSection.classList.toggle('hidden', !authed || CURRENT_VIEW !== 'articles');

    ['newBtn','saveBtn','deleteBtn','reloadBtn','addLinkBtn','multiBtn','deleteSelectedBtn','newArticleBtn','saveArticleBtn','deleteArticleBtn','reloadArticlesBtn','viewItemsBtn','viewArticlesBtn'].forEach(id => {
      const btn = byId(id);
      if (btn) btn.disabled = !authed;
    });

    if (adminMain) {
      adminMain.querySelectorAll('input, textarea, select, button').forEach(el => {
        el.disabled = !authed;
      });
      if (!authed) {
        adminMain.querySelectorAll('input[type="text"], input[type="date"], input[type="datetime-local"], textarea').forEach(el => { el.value = ''; });
        adminMain.querySelectorAll('input[type="checkbox"]').forEach(el => { el.checked = false; });
        adminMain.querySelectorAll('select').forEach(el => { el.selectedIndex = -1; });
      }
    }

    if (!authed) {
      if (fileInfo) fileInfo.textContent = '';
      if (listEl) listEl.innerHTML = '';
      updateDeployStatus('');
      const raw = byId('f_raw');
      if (raw) raw.value = '';
      if (articleList) articleList.innerHTML = '';
      if (articleStatus) articleStatus.textContent = '';
      if (articleFileInfo) articleFileInfo.textContent = '-';
      ARTICLE_CURRENT = null;
      ARTICLE_PENDING.cover = null;
    }

    updateSelectionStatus();

    if (authed) setView(CURRENT_VIEW, { force: true });
  }

  // Build/deploy notice helpers
  function showNotice(msg){ const n = byId('buildNotice'); if (!n) return; n.classList.remove('hidden'); const m = n.querySelector('.msg'); if (m) m.textContent = String(msg||''); }
  function updateNotice(msg){ const n = byId('buildNotice'); if (!n) return; const m = n.querySelector('.msg'); if (m) m.textContent = String(msg||''); }
  function hideNotice(){ const n = byId('buildNotice'); if (!n) return; n.classList.add('hidden'); }

  // Pending uploads staged until Save
  const PENDING = { thumb: null, card: null };
  function planAsset(kind, file, baseDir, publicBase, inputId){
    const path = uniqueMediaPath(file, baseDir);
    const fname = path.replace(/^.*\//,'');
    const pub = String(publicBase||'').replace(/\/$/,'') + '/' + fname;
    PENDING[kind] = { file, path, publicUrl: pub };
    const inp = byId(inputId);
    if (inp) inp.value = pub;
    if (saveStatus) saveStatus.textContent = `Immagine ${kind} pronta: verrÃ  caricata al Salva`;
  }

function setWho(user){
  const el = byId("who");
  if (el) el.textContent = user ? `Autenticato come ${user.login}` : "Non autenticato";
  setAuthState(!!user);
}
async function fetchMe(){
  if (!TOKEN) return null;
  const r = await gh("https://api.github.com/user");
  if (!r.ok) return null;
  return r.json();
}

/* ====== LOGIN / LOGOUT ====== */
byId("loginBtn").onclick = () => {
  const origin = location.origin;
  const url = `${WORKER_BASE}/${AUTH_ENDPOINT}?origin=${encodeURIComponent(origin)}&scope=repo${APP_ID?`&client_id=${encodeURIComponent(APP_ID)}`:""}`;
  OAUTH_POPUP = window.open(url, "oauth", "width=980,height=720"); // necessario mantenere opener per ricevere postMessage
};
byId("logoutBtn").onclick = () => {
  try { sessionStorage.removeItem("gh_token"); } catch(_){ }
  try { localStorage.removeItem("gh_token"); } catch(_){ }
  TOKEN = "";
  OAUTH_POPUP = null;
  setWho(null);
  alert("Logout eseguito.");
};

/* Ricezione token dal popup */
window.addEventListener("message", async (e) => {
  // Validazione origin robusta
  try {
    const eventOrigin = new URL(e.origin).origin;
    if (eventOrigin !== WORKER_ORIGIN) {
      console.warn('Messaggio OAuth ricevuto da origin non autorizzato:', eventOrigin);
      return;
    }
  } catch(err) {
    console.error('Errore parsing origin OAuth:', err);
    return;
  }

  // Validazione tipo messaggio
  if (typeof e.data !== "string") {
    console.warn('Messaggio OAuth non stringa:', typeof e.data);
    return;
  }

  // Validazione formato messaggio
  if (!e.data.startsWith("authorization:github:success:")) return;

  // Validazione source (deve essere il popup aperto da noi)
  if (OAUTH_POPUP && e.source !== OAUTH_POPUP) {
    console.warn('Messaggio OAuth da source non autorizzato');
    return;
  }

  const tok = e.data.slice("authorization:github:success:".length);
  if (!tok || tok.length < 10) {
    console.warn('Token OAuth invalido o troppo corto');
    return;
  }
  TOKEN = tok;
  try { sessionStorage.setItem("gh_token", TOKEN); } catch(_){ }
  try { localStorage.removeItem("gh_token"); } catch(_){ }
  if (OAUTH_POPUP) {
    try { OAUTH_POPUP.close(); } catch(_){ }
    OAUTH_POPUP = null;
  }
  const me = await fetchMe();
  setWho(me);
  if (me) {
    setView(CURRENT_VIEW, { force: true, skipLoad: true });
    await Promise.all([
      loadList().catch(()=>{}),
      loadArticlesList().catch(()=>{})
    ]);
  } else {
    TOKEN = "";
    try { sessionStorage.removeItem('gh_token'); } catch(_){ }
    try { localStorage.removeItem('gh_token'); } catch(_){ }
    alert('Autenticazione fallita. Riprova.');
  }
});

/* ====== UPLOAD ASSET (THUMB) ====== */
function sanitizeFilename(name){
  const dot = name.lastIndexOf('.');
  const base = name.slice(0, dot >= 0 ? dot : undefined);
  const ext = dot >= 0 ? name.slice(dot) : '';
  return `${kebab(base)}${ext.toLowerCase()}`;
}
function uniqueMediaPath(file, baseDir){
  const now = new Date();
  const pad = (n)=> String(n).padStart(2,'0');
  const stamp = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
  const clean = sanitizeFilename(file.name || 'asset');
  const root = String(baseDir||MEDIA_FOLDER).replace(/\/$/, '');
  return `${root}/${stamp}-${clean}`;
}
async function uploadAssetFileTo(file, baseDir, publicBase){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onerror = () => reject(new Error('Lettura file fallita'));
    fr.onload = async () => {
      try {
        const dataUrl = String(fr.result||'');
        const base64 = dataUrl.split(',')[1] || '';
        const path = uniqueMediaPath(file, baseDir);
        const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`;
        async function putBody(sha){
          const body = { message: `chore(admin): upload ${path}`, content: base64, branch: BRANCH, ...(sha?{sha}: {}) };
          return gh(url, { method: 'PUT', body: JSON.stringify(body) });
        }
        let r = await putBody(null);
        if (r.status === 422) {
          const g = await gh(url);
          if (g.ok) {
            const j = await g.json();
            r = await putBody(j.sha);
          }
        }
        if (!r.ok) { const t = await r.text().catch(()=>String(r.status)); throw new Error(`Upload fallito: ${r.status} ${t}`); }
        // Calcola URL pubblico (static/... -> /...)
        let pub = '';
        if (publicBase) {
          const base = String(publicBase).replace(/\/$/, '');
          const fname = path.replace(/^.*\//,'');
          pub = `${base}/${fname}`;
        } else {
          pub = `/${path.replace(/^static\//,'')}`;
        }
        resolve({ path, publicUrl: pub });
      } catch (err) { reject(err); }
    };
    fr.readAsDataURL(file);
  });
}

async function uploadAssetFileToPath(file, fullPath){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onerror = () => reject(new Error('Lettura file fallita'));
    fr.onload = async () => {
      try {
        const dataUrl = String(fr.result||'');
        const base64 = dataUrl.split(',')[1] || '';
        const path = fullPath;
        const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`;
        async function putBody(sha){
          const body = { message: `chore(admin): upload ${path}` , content: base64, branch: BRANCH, ...(sha?{sha}: {}) };
          return gh(url, { method: 'PUT', body: JSON.stringify(body) });
        }
        let r = await putBody(null);
        if (r.status === 422) {
          const g = await gh(url);
          if (g.ok) {
            const j = await g.json();
            r = await putBody(j.sha);
          }
        }
        if (!r.ok) { const t = await r.text().catch(()=>String(r.status)); throw new Error(`Upload fallito: ${r.status} ${t}`); }
        const publicUrl = '/' + path.replace(/^static\//,'');
        resolve({ path, publicUrl });
      } catch (err) { reject(err); }
    };
    fr.readAsDataURL(file);
  });
}
if (btnUploadThumb && uploadThumbInput) {
  btnUploadThumb.onclick = () => uploadThumbInput.click();
  uploadThumbInput.onchange = async () => {
    if (!uploadThumbInput.files || !uploadThumbInput.files[0]) return;
    const file = uploadThumbInput.files[0];
    planAsset('thumb', file, THUMBS_DIR, THUMBS_PUBLIC, 'f_thumb');
    uploadThumbInput.value = '';
  };
}

if (btnUploadCard && uploadCardInput) {
  btnUploadCard.onclick = () => uploadCardInput.click();
  uploadCardInput.onchange = async () => {
    if (!uploadCardInput.files || !uploadCardInput.files[0]) return;
    const file = uploadCardInput.files[0];
    planAsset('card', file, CARDS_DIR, CARDS_PUBLIC, 'f_card');
    uploadCardInput.value = '';
  };
}

if (btnBrowseThumb && thumbBrowser && fThumb) {
  btnBrowseThumb.onclick = async () => {
    if (!TOKEN) { alert('Prima fai login.'); return; }
    const items = await listImages(THUMBS_DIR, 2).catch(()=>[]);
    renderAssetBrowser(thumbBrowser, items, fThumb);
    PENDING.thumb = null;
  };
}
  if (btnBrowseCard && cardBrowser && fCard) {
    btnBrowseCard.onclick = async () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      let items = await listImages(CARDS_DIR, 2).catch(()=>[]);
      renderAssetBrowser(cardBrowser, items, fCard);
      PENDING.card = null;
    };
  }

  if (multiBtn) {
    multiBtn.onclick = () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      if (isDeployLocked()) { alert('Operazione non disponibile durante un deploy.'); return; }
      setMultiMode(!MULTI_MODE);
    };
  }

  if (deleteSelectedBtn) {
    deleteSelectedBtn.onclick = async () => {
      if (!MULTI_MODE) return;
      if (SELECTED_ITEMS.size === 0) return alert('Nessun elemento selezionato.');
      if (!TOKEN) { alert('Prima fai login.'); return; }
      if (isDeployLocked()) { alert('E\' in corso un deploy precedente. Attendi il completamento.'); return; }
      if (!confirm(`Eliminare ${SELECTED_ITEMS.size} elementi selezionati?`)) return;

      setDeployLock(true, 'Eliminazione multipla in corso...');
      const entries = Array.from(SELECTED_ITEMS.entries());
      let success = false;
      try {
        let idx = 0;
        for (const [path, info] of entries) {
          idx += 1;
          updateDeployStatus(`Elimino ${path} (${idx}/${entries.length})...`);
          const sha = await ensureContentSha(path, info && info.sha);
          await deleteContent(path, sha);
        }
        SELECTED_ITEMS.clear();
        CURRENT = null;
        fillForm({}, "", "-");
        await loadList();
        try { await resetSiteCaches(); } catch(_){ }
        updateDeployStatus('Deploy in corso...');
        const ok = await monitorDeployAndReload().catch(()=>false);
        if (ok) updateDeployStatus('Deploy completato');
        else {
          updateDeployStatus('Deploy non confermato, ricarico...');
          const urlReload = new URL(window.location.href);
          urlReload.searchParams.set('t', String(Date.now()));
          window.location.replace(urlReload.toString());
        }
        setMultiMode(false, { skipReload: true, resetSelection: true, force: true });
        const statusEl = byId('saveStatus');
        if (statusEl) {
          delete statusEl.dataset.selectionStatus;
          statusEl.textContent = `Eliminati ${entries.length} file.`;
        }
        updateSelectionStatus();
        success = true;
      } catch (err) {
        alert(err && err.message ? err.message : err);
      } finally {
        setDeployLock(false);
        if (!success) updateSelectionStatus();
      }
    };
  }

  if (viewItemsBtn) {
    viewItemsBtn.onclick = () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      setView('items');
    };
  }

  if (viewArticlesBtn) {
    viewArticlesBtn.onclick = () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      setView('articles');
    };
  }

  if (newArticleBtn) {
    newArticleBtn.onclick = () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      if (isDeployLocked()) { alert('Operazione non disponibile durante un deploy.'); return; }
      const now = new Date();
      const baseSlug = kebab((aTitle && aTitle.value) || 'nuovo-articolo');
      const slug = baseSlug || `articolo-${now.getTime()}`;
      const iso = now.toISOString();
      const front = { title: 'Nuovo articolo', date: iso, draft: true, description: '', tags: [], cover: '' };
      const body = '# Nuovo articolo\n\n';
      ARTICLE_CURRENT = { path: articlePathFromSlug(slug), sha: null, front, body, slug };
      ARTICLE_PENDING.cover = null;
      fillArticleForm(front, body, ARTICLE_CURRENT.path, slug);
      applyArticleFormDefaults();
      if (aDraft) aDraft.checked = true;
      if (deleteArticleBtn) deleteArticleBtn.disabled = true;
      updateArticleStatus('Articolo pronto: compila i campi e salva.');
      setView('articles', { force: true, skipLoad: true });
      initMarkdownEditor();
      startAutoSave();
    };
  }

  if (aTitle && aSlug) {
    // Validazione lunghezza titolo
    aTitle.addEventListener('input', () => {
      const len = aTitle.value.length;
      if (len > 0 && len < 10) {
        aTitle.style.borderColor = 'var(--warn)';
      } else if (len > 100) {
        aTitle.style.borderColor = 'var(--danger)';
      } else {
        aTitle.style.borderColor = '';
      }
    });

    aTitle.addEventListener('blur', () => {
      if (!aSlug.value.trim()) aSlug.value = kebab(aTitle.value || '');
    });
    aSlug.addEventListener('blur', () => {
      const val = kebab(aSlug.value || '');
      aSlug.value = val;
      ARTICLE_PENDING.cover = null;

      // Validate slug format and length
      if (val.length > 0 && val.length < 3) {
        aSlug.style.borderColor = 'var(--warn)';
        updateArticleStatus('⚠️ Slug troppo corto (min 3 caratteri)');
        return;
      } else if (val.length > 100) {
        aSlug.style.borderColor = 'var(--danger)';
        updateArticleStatus('⚠️ Slug troppo lungo (max 100 caratteri)');
        return;
      } else if (val && !/^[a-z0-9-]+$/.test(val)) {
        aSlug.style.borderColor = 'var(--danger)';
        updateArticleStatus('⚠️ Slug deve contenere solo lettere minuscole, numeri e trattini');
        return;
      }

      // Validate duplicate slug
      if (val && TOKEN) {
        const testPath = articlePathFromSlug(val);
        if (!ARTICLE_CURRENT || ARTICLE_CURRENT.path !== testPath) {
          const exists = Array.from(ARTICLES_CACHE.values()).some(a => a.path === testPath);
          if (exists) {
            aSlug.style.borderColor = 'red';
            updateArticleStatus('⚠️ Attenzione: questo slug esiste già!');
          } else {
            aSlug.style.borderColor = '';
            if (byId('articleStatus').textContent.includes('slug') || byId('articleStatus').textContent.includes('Slug')) {
              updateArticleStatus('');
            }
          }
        } else {
          aSlug.style.borderColor = '';
        }
      }
    });
    aSlug.addEventListener('input', () => { ARTICLE_PENDING.cover = null; });
  }

  if (aBtnUploadCover && aCoverUpload) {
    aBtnUploadCover.onclick = () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      const slug = kebab(aSlug?.value || aTitle?.value || '');
      if (!slug) { alert('Imposta titolo o slug prima di caricare la cover.'); return; }
      aSlug.value = slug;
      aCoverUpload.click();
    };
    aCoverUpload.onchange = () => {
      if (!aCoverUpload.files || !aCoverUpload.files[0]) return;
      try {
        const slug = kebab(aSlug?.value || aTitle?.value || '');
        if (!slug) throw new Error('Imposta titolo o slug prima di caricare la cover.');
        planArticleCover(aCoverUpload.files[0], slug);
      } catch (err) {
        alert(err && err.message ? err.message : err);
      } finally {
        aCoverUpload.value = '';
      }
    };
  }

  // Upload multiplo immagini contenuto
  const btnUploadContentImage = byId('a_btnUploadContentImage');
  const contentImageUpload = byId('a_contentImageUpload');
  const contentImagesList = byId('a_contentImagesList');

  if (btnUploadContentImage && contentImageUpload && contentImagesList) {
    btnUploadContentImage.onclick = () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      const slug = kebab(aSlug?.value || aTitle?.value || '');
      if (!slug) { alert('Imposta titolo o slug prima di caricare immagini.'); return; }
      contentImageUpload.click();
    };

    contentImageUpload.onchange = async () => {
      const files = contentImageUpload.files;
      if (!files || !files.length) return;

      const slug = kebab(aSlug?.value || aTitle?.value || '');
      if (!slug) {
        alert('Imposta titolo o slug prima di caricare immagini.');
        contentImageUpload.value = '';
        return;
      }

      updateArticleStatus(`Upload ${files.length} immagini in corso...`);
      btnUploadContentImage.disabled = true;

      const uploaded = [];
      for (let i = 0; i < files.length; i++) {
        try {
          const file = files[i];
          const path = uniqueMediaPath(file, `${ARTICLES_MEDIA_DIR}/${slug}`);
          const res = await uploadAssetFileToPath(file, path);
          uploaded.push(res);
          updateArticleStatus(`Upload ${i + 1}/${files.length}...`);
        } catch (e) {
          console.error('Upload fallito:', e);
          alert(`Errore upload immagine ${i + 1}: ${e.message || e}`);
        }
      }

      // Mostra immagini caricate
      contentImagesList.innerHTML = '';
      contentImagesList.style.display = uploaded.length > 0 ? 'grid' : 'none';

      uploaded.forEach(img => {
        const div = document.createElement('div');
        div.className = 'asset';
        div.style.cssText = 'position:relative;';

        const imgEl = document.createElement('img');
        imgEl.src = img.publicUrl;
        imgEl.alt = img.name || '';
        imgEl.style.cssText = 'width:100%;height:100px;object-fit:cover;border-radius:8px;border:1px solid var(--border);';

        const copyBtn = document.createElement('button');
        copyBtn.className = 'btn';
        copyBtn.style.cssText = 'width:100%;padding:4px 8px;font-size:12px;margin-top:4px;';
        copyBtn.textContent = 'Copia Markdown';
        copyBtn.type = 'button';
        copyBtn.onclick = () => {
          const md = `![${img.name || 'alt'}](${img.publicUrl})`;
          navigator.clipboard.writeText(md).then(() => {
            const oldText = copyBtn.textContent;
            copyBtn.textContent = '✓ Copiato!';
            setTimeout(() => { copyBtn.textContent = oldText; }, 1500);
          }).catch(() => {
            prompt('Copia questo Markdown:', md);
          });
        };

        div.appendChild(imgEl);
        div.appendChild(copyBtn);
        contentImagesList.appendChild(div);
      });

      updateArticleStatus(`✓ ${uploaded.length} immagini caricate`);
      btnUploadContentImage.disabled = false;
      contentImageUpload.value = '';
    };
  }

  if (aBtnBrowseCover && aCoverBrowser && aCover) {
    aBtnBrowseCover.onclick = async () => {
      if (!TOKEN) { alert('Prima fai login.'); return; }
      const slug = kebab(aSlug?.value || '');
      let items = await listImages(slug ? `${ARTICLES_MEDIA_DIR}/${slug}` : ARTICLES_MEDIA_DIR, 3).catch(()=>[]);
      if ((!items || !items.length) && slug) {
        items = await listImages(ARTICLES_MEDIA_DIR, 2).catch(()=>[]);
      }
      renderAssetBrowser(aCoverBrowser, items, aCover);
      ARTICLE_PENDING.cover = null;
    };
  }

  async function saveArticle(){
    if (!TOKEN) { alert('Prima fai login.'); return; }
    const form = collectArticleForm();
    if (!form.title) return alert('Titolo articolo obbligatorio.');
    if (!form.slug) return alert('Slug articolo obbligatorio.');
    if (aSlug) aSlug.value = form.slug;
    const front = {
      title: form.title,
      date: form.date || new Date().toISOString(),
      draft: form.draft,
      description: form.description,
      tags: form.tags,
      cover: form.cover
    };
    const body = form.body;
    const newPath = articlePathFromSlug(form.slug);
    const previousPath = ARTICLE_CURRENT ? ARTICLE_CURRENT.path : null;
    const isRename = previousPath && previousPath !== newPath;

    setDeployLock(true, 'Salvataggio articolo...');
    updateArticleStatus('Salvataggio articolo...');
    try {
      if (ARTICLE_PENDING.cover) {
        updateArticleStatus('Upload cover in corso...');
        const res = await uploadAssetFileToPath(ARTICLE_PENDING.cover.file, ARTICLE_PENDING.cover.path);
        ARTICLE_PENDING.cover = null;
        front.cover = res.publicUrl;
        if (aCover) aCover.value = res.publicUrl;
      }

      const content = buildArticleContent(front, body);
      const encoded = b64.enc(content);
      const putArticleSmart = async (path, shaMaybe) => {
        const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`;
        const makeBody = (sha) => JSON.stringify({
          message: `chore(admin): ${sha ? 'update' : 'create'} ${path}`,
          content: encoded,
          branch: BRANCH,
          ...(sha ? { sha } : {})
        });
        if (shaMaybe) return gh(url, { method: 'PUT', body: makeBody(shaMaybe) });
        let r = await gh(url, { method: 'PUT', body: makeBody(null) });
        if (r.status === 422) {
          const g = await gh(url);
          if (g.ok) {
            const j = await g.json();
            r = await gh(url, { method: 'PUT', body: makeBody(j.sha) });
          }
        }
        return r;
      };

      let response;
      if (isRename) {
        response = await putArticleSmart(newPath, null);
        if (!response.ok) {
          const t = await response.text().catch(() => String(response.status));
          throw new Error(`Errore salvataggio: ${response.status} - ${t}`);
        }
        const created = await response.json();
        if (previousPath) {
          const prevSha = await ensureContentSha(previousPath, ARTICLE_CURRENT ? ARTICLE_CURRENT.sha : null);
          try {
            await deleteContent(previousPath, prevSha);
          } catch (err) {
            console.warn('Impossibile eliminare il vecchio articolo:', err);
          }
        }
        ARTICLE_CURRENT = { path: newPath, sha: created.content.sha, front, body, slug: form.slug };
      } else {
        const shaMaybe = ARTICLE_CURRENT ? ARTICLE_CURRENT.sha : null;
        response = await putArticleSmart(newPath, shaMaybe);
        if (!response.ok) {
          const t = await response.text().catch(() => String(response.status));
          throw new Error(`Errore salvataggio: ${response.status} - ${t}`);
        }
        const saved = await response.json();
        ARTICLE_CURRENT = { path: newPath, sha: saved.content.sha, front, body, slug: form.slug };
      }

      fillArticleForm(front, body, ARTICLE_CURRENT.path, form.slug);
      ARTICLES_CACHE.set(ARTICLE_CURRENT.path, {
        path: ARTICLE_CURRENT.path,
        sha: ARTICLE_CURRENT.sha,
        title: front.title,
        date: Date.parse(front.date || '') || 0,
        draft: !!front.draft,
        front: { ...front },
        body
      });
      updateArticleStatus('Articolo salvato.');
      if (deleteArticleBtn) deleteArticleBtn.disabled = false;
      clearArticleDraft();
      await loadArticlesList();
      try { await resetSiteCaches(); } catch(_){ }
      const ok = await monitorDeployAndReload().catch(()=>false);
      if (ok) updateArticleStatus('Deploy completato');
      else {
        updateArticleStatus('Deploy non confermato, ricarico...');
        const urlReload = new URL(window.location.href);
        urlReload.searchParams.set('t', String(Date.now()));
        window.location.replace(urlReload.toString());
      }
    } catch (err) {
      alert(err && err.message ? err.message : err);
      updateArticleStatus('Errore salvataggio articolo');
    } finally {
      setDeployLock(false);
    }
  }

  async function deleteArticle(){
    if (!TOKEN) { alert('Prima fai login.'); return; }
    if (!ARTICLE_CURRENT || !ARTICLE_CURRENT.path) return alert('Nessun articolo aperto.');
    if (!ARTICLE_CURRENT.sha) return alert('Salva l\'articolo prima di eliminarlo.');
    if (!confirm(`Eliminare ${ARTICLE_CURRENT.path}?`)) return;
    setDeployLock(true, 'Eliminazione articolo...');
    updateArticleStatus('Eliminazione articolo...');
    try {
      const prevPath = ARTICLE_CURRENT.path;
      const sha = await ensureContentSha(prevPath, ARTICLE_CURRENT.sha);
      await deleteContent(prevPath, sha);
      ARTICLES_CACHE.delete(prevPath);
      ARTICLE_CURRENT = null;
      clearArticleForm();
      if (deleteArticleBtn) deleteArticleBtn.disabled = true;
      await loadArticlesList();
      try { await resetSiteCaches(); } catch(_){ }
      const ok = await monitorDeployAndReload().catch(()=>false);
      if (ok) updateArticleStatus('Articolo eliminato');
      else {
        updateArticleStatus('Deploy non confermato, ricarico...');
        const urlReload = new URL(window.location.href);
        urlReload.searchParams.set('t', String(Date.now()));
        window.location.replace(urlReload.toString());
      }
    } catch (err) {
      alert(err && err.message ? err.message : err);
      updateArticleStatus('Errore eliminazione articolo');
    } finally {
      setDeployLock(false);
    }
  }

  if (saveArticleBtn) {
    saveArticleBtn.onclick = () => {
      if (isDeployLocked()) { alert('Operazione non disponibile durante un deploy.'); return; }
      saveArticle();
    };
  }

  if (deleteArticleBtn) {
    deleteArticleBtn.onclick = () => {
      if (isDeployLocked()) { alert('Operazione non disponibile durante un deploy.'); return; }
      deleteArticle();
    };
  }

/* ====== CARICAMENTO LISTA FILE ====== */
let CURRENT_DIR = null;
async function loadList(path){
  if (!TOKEN) {
    listEl.innerHTML = '';
    return;
  }
  if (path) CURRENT_DIR = path; else CURRENT_DIR = CURRENT_DIR || FOLDER;
  listEl.innerHTML = "";
  const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${CURRENT_DIR}?ref=${encodeURIComponent(BRANCH)}`;
  const r = await gh(url);
  if (!r.ok) {
    const msg = document.createElement('div');
    msg.className = 'muted';
    msg.textContent = `Impossibile leggere la cartella (${r.status}). Verifica token/permessi/branch.`;
    listEl.appendChild(msg);
    return;
  }
  const items = await r.json();
  if (CURRENT_DIR !== FOLDER) {
    const up = document.createElement('div');
    up.className = 'item item--dir';
    const info = document.createElement('div');
    info.className = 'item-info';
    const st = document.createElement('strong');
    st.textContent = '..';
    const sp = document.createElement('span');
    sp.className = 'meta';
    sp.textContent = 'Torna su';
    info.appendChild(st);
    info.appendChild(sp);
    up.appendChild(info);
    up.onclick = () => {
      const p = CURRENT_DIR.replace(/\\/g,'/');
      const i = p.lastIndexOf('/');
      const parent = i>0 ? p.slice(0,i) : FOLDER;
      loadList(parent);
    };
    listEl.appendChild(up);
  }
  const dirs = items.filter(x => x.type === 'dir');
  const files = items.filter(x => x.type === 'file' && /\.ya?ml$/i.test(x.name));
  dirs.forEach((d) => {
    const div = document.createElement('div');
    div.className = 'item item--dir';
    const strong = document.createElement('strong');
    strong.style.fontWeight = '600';
    strong.style.fontSize = '13px';
    strong.textContent = String(d.name || '');
    const meta = document.createElement('span');
    meta.className = 'meta';
    meta.textContent = String(d.path || '');
    div.appendChild(strong);
    div.appendChild(meta);
    div.onclick = () => loadList(d.path);
    listEl.appendChild(div);
  });
  if (files.length === 0 && dirs.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'muted';
    empty.textContent = 'Cartella vuota.';
    listEl.appendChild(empty);
  }
  // Preleva metadati (data/draft) e ordina per data desc
  const metas = await Promise.all(files.map(async (f) => {
    try {
      const ur = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${f.path}?ref=${encodeURIComponent(BRANCH)}`;
      const rr = await gh(ur);
      if (!rr.ok) return { f, date: 0, draft: false };
      const j = await rr.json();
      const raw = b64.dec(j.content);
      const yml = jsyaml.load(raw) || {};
      const ds = String(yml.date || '');
      const d = Date.parse(ds);
      return { f, date: isNaN(d) ? 0 : d, draft: !!yml.draft };
    } catch(_) { return { f, date: 0, draft: false }; }
  }));
  metas.sort((a,b) => (b.date - a.date) || a.f.name.localeCompare(b.f.name));
  const availablePaths = new Set();
  for (const m of metas) {
    const f = m.f;
    availablePaths.add(f.path);
    const div = document.createElement('div');
    div.className = 'item' + (m.draft ? ' is-draft' : '');
    div.dataset.path = f.path;
    div.dataset.sha = f.sha || '';
    const strong = document.createElement('strong');
    strong.style.fontWeight = '600';
    strong.style.fontSize = '13px';
    strong.textContent = String(f.name || '');
    const meta = document.createElement('span');
    meta.className = 'meta';
    meta.textContent = String(f.path || '');

    if (MULTI_MODE) {
      const chkWrap = document.createElement('label');
      chkWrap.className = 'item-checkbox';
      const chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.className = 'item-select';
      chk.checked = SELECTED_ITEMS.has(f.path);
      chk.onclick = (ev) => ev.stopPropagation();
      chk.onchange = (ev) => {
        const next = !!ev.target.checked;
        const sha = f.sha || div.dataset.sha || '';
        toggleSelection(f.path, sha, next, div);
      };
      chkWrap.appendChild(chk);
      div.appendChild(chkWrap);
    }

    const info = document.createElement('div');
    info.className = 'item-info';
    info.appendChild(strong);
    info.appendChild(meta);
    if (m.draft) {
      const s = document.createElement('span');
      s.className = 'pill pill--warn';
      s.textContent = 'Draft';
      info.appendChild(s);
    }
    div.appendChild(info);

    if (MULTI_MODE) {
      div.classList.toggle('is-selected', SELECTED_ITEMS.has(f.path));
      div.onclick = () => {
        const next = !SELECTED_ITEMS.has(f.path);
        const sha = f.sha || div.dataset.sha || '';
        toggleSelection(f.path, sha, next, div);
        const cb = div.querySelector('.item-select');
        if (cb) cb.checked = next;
      };
    } else {
      div.onclick = () => openFile(f.path);
    }
    listEl.appendChild(div);
  }
  if (MULTI_MODE) {
    for (const key of Array.from(SELECTED_ITEMS.keys())) {
      if (!availablePaths.has(key)) SELECTED_ITEMS.delete(key);
    }
  }
  updateSelectionStatus();
}

/* ====== ARTICOLI ====== */
function parseTomlValue(str){
  if (str == null) return '';
  const trimmed = String(str).trim();

  // Boolean
  if (/^(true|false)$/i.test(trimmed)) return trimmed.toLowerCase() === 'true';

  // Stringhe quotate (singole o doppie)
  if (/^["'].*["']$/.test(trimmed)) {
    const quote = trimmed[0];
    const content = trimmed.slice(1, -1);
    // Unescape solo le quote matchate
    return content.replace(new RegExp(`\\\\${quote}`, 'g'), quote);
  }

  // Array: usiamo regex più robusta per evitare false match su stringhe con brackets
  // Match solo se inizia con [ e finisce con ] SENZA quotes attorno
  if (/^\[/.test(trimmed) && /\]$/.test(trimmed) && !/^["']/.test(trimmed)) {
    const inner = trimmed.slice(1, -1).trim();
    if (!inner) return [];

    // Split su virgole MA rispettando le quote
    const items = [];
    let current = '';
    let inQuote = false;
    let quoteChar = '';

    for (let i = 0; i < inner.length; i++) {
      const char = inner[i];
      const prevChar = i > 0 ? inner[i-1] : '';

      if ((char === '"' || char === "'") && prevChar !== '\\') {
        if (!inQuote) {
          inQuote = true;
          quoteChar = char;
        } else if (char === quoteChar) {
          inQuote = false;
          quoteChar = '';
        }
      }

      if (char === ',' && !inQuote) {
        items.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }

    if (current.trim()) items.push(current.trim());
    return items.map(s => parseTomlValue(s)).filter(v => v !== '');
  }

  // Numero
  if (/^-?\d+(\.\d+)?$/.test(trimmed)) {
    const num = parseFloat(trimmed);
    return isNaN(num) ? trimmed : num;
  }

  // Default: stringa senza quote (bare string)
  return trimmed;
}

function serializeTomlValue(val){
  if (Array.isArray(val)) {
    return `[${val.map(v => serializeTomlValue(v)).join(', ')}]`;
  }
  if (typeof val === 'boolean') return val ? 'true' : 'false';
  const str = String(val ?? '').replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  return `"${str}"`;
}

function parseArticleFile(raw){
  const match = raw.match(/^\s*\+\+\+[\r\n]+([\s\S]*?)[\r\n]+\+\+\+[\r\n]*([\s\S]*)$/);
  if (!match) return { front: {}, body: raw };
  const frontText = match[1];
  const body = match[2].replace(/^\s+/, '');
  const front = {};
  frontText.split(/\r?\n/).forEach(line => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) return;
    const idx = trimmed.indexOf('=');
    if (idx < 0) return;
    const key = trimmed.slice(0, idx).trim();
    const val = trimmed.slice(idx + 1).trim();
    front[key] = parseTomlValue(val);
  });
  return { front, body };
}

function buildArticleContent(front, body){
  const lines = [];
  lines.push(`title = ${serializeTomlValue(front.title || '')}`);
  if (front.date) lines.push(`date = ${serializeTomlValue(front.date)}`);
  lines.push(`draft = ${serializeTomlValue(!!front.draft)}`);
  if (front.description) lines.push(`description = ${serializeTomlValue(front.description)}`);
  const tags = Array.isArray(front.tags) ? front.tags.filter(Boolean) : [];
  lines.push(`tags = ${serializeTomlValue(tags)}`);
  if (front.cover) lines.push(`cover = ${serializeTomlValue(front.cover)}`);
  const bodyOut = (body || '').replace(/\s+$/, '');
  return `+++\n${lines.join('\n')}\n+++\n\n${bodyOut}\n`;
}

function articlePathFromSlug(slug){
  return `${ARTICLES_DIR}/${slug}.${ARTICLES_EXT}`;
}

function toDateInputValue(iso){
  if (!iso) return '';
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return '';
  const local = new Date(d.getTime() - d.getTimezoneOffset() * 60000);
  return local.toISOString().slice(0,16);
}

function toIsoFromInput(value){
  if (!value) return '';
  const d = new Date(value);
  if (Number.isNaN(d.getTime())) return '';
  return d.toISOString();
}

function fillArticleForm(front={}, body='', path='', slug=''){
  if (aTitle) aTitle.value = front.title || '';
  const resolvedSlug = slug || (path ? path.split('/').pop().replace(/\.[^/.]+$/, '') : '');
  if (aSlug) aSlug.value = resolvedSlug;
  if (aDate) aDate.value = toDateInputValue(front.date || '');
  if (aDraft) aDraft.checked = !!front.draft;
  if (aDescription) aDescription.value = front.description || '';
  if (aTags) aTags.value = Array.isArray(front.tags) ? front.tags.join(', ') : '';
  if (aCover) aCover.value = front.cover || '';
  if (aBody) aBody.value = body || '';
  if (articleFileInfo) articleFileInfo.textContent = path || '-';
  if (deleteArticleBtn) deleteArticleBtn.disabled = !ARTICLE_CURRENT || !ARTICLE_CURRENT.sha;
  ARTICLE_PENDING.cover = null;
  updateArticleStatus('');
}

function clearArticleForm(){
  fillArticleForm({}, '', '', '');
}

function applyArticleFilters() {
  if (!articleList) return;

  const searchInput = byId('articleSearchInput');
  const filterDraft = byId('articleFilterDraft');

  const searchQuery = searchInput ? searchInput.value.toLowerCase().trim() : '';
  const draftFilter = filterDraft ? filterDraft.value : 'all';

  const items = articleList.querySelectorAll('.item');
  let visibleCount = 0;
  let draftCount = 0;
  let publishedCount = 0;

  items.forEach(item => {
    const searchText = item.dataset.searchText || '';
    const isDraft = item.dataset.isDraft === 'true';

    // Search filter
    const matchesSearch = !searchQuery || searchText.includes(searchQuery);

    // Draft filter
    let matchesDraft = true;
    if (draftFilter === 'drafts') matchesDraft = isDraft;
    else if (draftFilter === 'published') matchesDraft = !isDraft;

    const visible = matchesSearch && matchesDraft;
    item.style.display = visible ? '' : 'none';

    if (visible) visibleCount++;
    if (isDraft) draftCount++;
    else publishedCount++;
  });

  // Update filter dropdown with counts
  if (filterDraft && filterDraft.options) {
    filterDraft.options[0].textContent = `Tutti (${items.length})`;
    filterDraft.options[1].textContent = `Pubblicati (${publishedCount})`;
    filterDraft.options[2].textContent = `Solo bozze (${draftCount})`;
  }
}

async function loadArticlesList(){
  if (!articleList) return;
  if (!TOKEN) { articleList.innerHTML = ''; return; }
  articleList.innerHTML = '';
  try {
    const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${ARTICLES_DIR}?ref=${encodeURIComponent(BRANCH)}`;
    const r = await gh(url);
    if (!r.ok) {
      const div = document.createElement('div');
      div.className = 'muted';
      div.textContent = `Impossibile leggere la cartella articoli (${r.status}).`;
      articleList.appendChild(div);
      return;
    }
    const items = await r.json();
    const files = items.filter(x => x.type === 'file' && /\.(md|markdown)$/i.test(x.name));
    if (!files.length) {
      const div = document.createElement('div');
      div.className = 'muted';
      div.textContent = 'Nessun articolo presente.';
      articleList.appendChild(div);
      return;
    }
    const metas = await Promise.all(files.map(async (f) => {
      try {
        const rr = await gh(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${f.path}?ref=${encodeURIComponent(BRANCH)}`);
        if (!rr.ok) throw new Error(`HTTP ${rr.status}`);
        const j = await rr.json();
        const raw = b64.dec(j.content);
        const parsed = parseArticleFile(raw);
        const dateVal = parsed.front.date ? Date.parse(parsed.front.date) : 0;
        return {
          path: f.path,
          sha: j.sha,
          title: parsed.front.title || f.name.replace(/\.[^/.]+$/, ''),
          date: Number.isNaN(dateVal) ? 0 : dateVal,
          draft: !!parsed.front.draft,
          front: parsed.front,
          body: parsed.body
        };
      } catch (err) {
        return {
          path: f.path,
          sha: f.sha,
          title: f.name.replace(/\.[^/.]+$/, ''),
          date: 0,
          draft: false,
          front: {},
          body: ''
        };
      }
    }));
    metas.sort((a, b) => (b.date - a.date) || a.title.localeCompare(b.title));
    ARTICLES_CACHE.clear();
    metas.forEach(meta => {
      ARTICLES_CACHE.set(meta.path, meta);
      const div = document.createElement('div');
      div.className = 'item' + (meta.draft ? ' is-draft' : '');
      div.dataset.path = meta.path;
      div.dataset.sha = meta.sha || '';
      const info = document.createElement('div');
      info.className = 'item-info';
      const strong = document.createElement('strong');
      strong.textContent = meta.title;
      const span = document.createElement('span');
      span.className = 'meta';
      span.textContent = meta.path;
      info.appendChild(strong);
      info.appendChild(span);
      if (meta.draft) {
        const badge = document.createElement('span');
        badge.className = 'pill pill--warn';
        badge.textContent = 'Draft';
        info.appendChild(badge);
      }
      div.appendChild(info);
      div.classList.toggle('active', ARTICLE_CURRENT && ARTICLE_CURRENT.path === meta.path);
      div.onclick = () => openArticle(meta.path);
      div.dataset.isDraft = meta.draft ? 'true' : 'false';
      div.dataset.searchText = `${meta.title.toLowerCase()} ${meta.path.toLowerCase()}`;
      articleList.appendChild(div);
    });

    // Applica filtri esistenti se presenti
    applyArticleFilters();
  } catch (err) {
    const div = document.createElement('div');
    div.className = 'muted';
    div.textContent = 'Errore nel caricamento degli articoli.';
    articleList.appendChild(div);
  }
}

async function openArticle(path){
  try {
    let meta = ARTICLES_CACHE.get(path);
    if (!meta) {
      const r = await gh(`https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}?ref=${encodeURIComponent(BRANCH)}`);
      if (!r.ok) {
        const t = await r.text().catch(()=>String(r.status));
        throw new Error(`Impossibile aprire l'articolo: ${r.status} - ${t}`);
      }
      const j = await r.json();
      const parsed = parseArticleFile(b64.dec(j.content));
      meta = {
        path,
        sha: j.sha,
        title: parsed.front.title || path.split('/').pop().replace(/\.[^/.]+$/, ''),
        date: parsed.front.date ? Date.parse(parsed.front.date) : 0,
        draft: !!parsed.front.draft,
        front: parsed.front,
        body: parsed.body
      };
      ARTICLES_CACHE.set(path, meta);
    }
    const slug = path.split('/').pop().replace(/\.[^/.]+$/, '');
    ARTICLE_CURRENT = { path, sha: meta.sha, front: { ...meta.front }, body: meta.body, slug };
    fillArticleForm(ARTICLE_CURRENT.front, ARTICLE_CURRENT.body, path, slug);
    const nodes = articleList ? articleList.children : [];
    Array.from(nodes).forEach(el => el.classList.toggle('active', el.dataset && el.dataset.path === path));
    updateArticleStatus('Articolo caricato.');
    if (deleteArticleBtn) deleteArticleBtn.disabled = !ARTICLE_CURRENT.sha;
    initMarkdownEditor();
    loadArticleDraft();
    startAutoSave();
  } catch (err) {
    alert(err && err.message ? err.message : err);
  }
}

function planArticleCover(file, slug){
  const cleanSlug = kebab(slug || '');
  if (!cleanSlug) throw new Error('Slug non valido per l\'upload della cover.');
  const path = uniqueMediaPath(file, `${ARTICLES_MEDIA_DIR}/${cleanSlug}`);
  const fileName = path.replace(/^.*\//,'');
  const publicUrl = `${ARTICLES_MEDIA_PUBLIC}/${cleanSlug}/${fileName}`.replace(/\/+/g, '/');
  ARTICLE_PENDING.cover = { file, path, publicUrl };
  if (aCover) aCover.value = publicUrl;
  updateArticleStatus('Cover pronta: verrà caricata al salvataggio.');
}

function collectArticleForm(){
  const title = aTitle?.value?.trim() || '';
  const slugInput = aSlug?.value?.trim() || '';
  const slug = kebab(slugInput || title);
  return {
    title,
    slug,
    date: toIsoFromInput(aDate?.value?.trim() || ''),
    draft: !!(aDraft && aDraft.checked),
    description: aDescription?.value?.trim() || '',
    tags: (aTags?.value || '').split(',').map(s => s.trim()).filter(Boolean),
    cover: aCover?.value?.trim() || '',
    body: aBody?.value || ''
  };
}

function applyArticleFormDefaults(){
  if (aTitle && !aTitle.value) aTitle.value = 'Nuovo articolo';
  if (aSlug && !aSlug.value) aSlug.value = kebab(aTitle.value || 'nuovo-articolo');
  if (aDate && !aDate.value) {
    const now = new Date();
    const local = new Date(now.getTime() - now.getTimezoneOffset() * 60000);
    aDate.value = local.toISOString().slice(0,16);
  }
}

/* ====== APRI FILE ====== */
async function openFile(path){
  [...listEl.children].forEach(el => el.classList.toggle("active", el.querySelector(".meta").textContent===path));
  const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}?ref=${encodeURIComponent(BRANCH)}`;
  const r = await gh(url);
  if (!r.ok) { alert("Errore apertura file: " + r.status); return; }
  const j = await r.json();
  const raw = b64.dec(j.content);
  let yml;
  try { yml = jsyaml.load(raw) || {}; } catch (e) { yml = {}; }
  CURRENT = { path, sha: j.sha, yaml: yml };
  fillForm(yml, raw, path);
}

function fillForm(y, raw, path){
  byId("f_date").value = (y.date||"").slice(0,10);
  byId("f_title").value = y.title||"";
  byId("f_slug").value = y.slug||"";
  byId("f_kind").value = y.kind||"";
  byId("f_overline").value = y.overline||"";
  byId("f_author").value = y.author||"";
  byId("f_desc").value = y.desc||"";
  byId("f_id").value = y.id || "";
  byId("f_thumb").value = y.thumb || "";
  byId("f_card").value = y.card || "";
  byId("f_tags").value = "";
  byId("f_draft").checked = !!y.draft;
  // Draft badge near file info (create if missing)
  (function(){
    let badge = document.getElementById('draftBadge');
    if (!badge) {
      const ref = document.getElementById('fileInfo');
      if (ref && ref.parentNode) {
        badge = document.createElement('span');
        badge.id = 'draftBadge';
        badge.className = 'pill pill--warn';
        ref.parentNode.insertBefore(badge, ref.nextSibling);
      }
    }
    if (badge) { badge.textContent = 'Draft'; badge.hidden = !y.draft; }
  })();
  renderSavedTags(Array.isArray(y.tags) ? y.tags : (y.tags ? [y.tags] : []));
  if (y.updated) {
    try {
      const d = new Date(y.updated);
      const iso = new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().slice(0,16);
      byId("f_updated").value = iso;
    } catch(_) { byId("f_updated").value = ""; }
  } else {
    byId("f_updated").value = "";
  }
  // Links UI
  const list = byId("linksList");
  list.innerHTML = "";
  const links = Array.isArray(y.links) ? y.links : (y.links ? [y.links] : []);
  for (const L of links) addLinkRow(L);
  const fd = byId('f_draft');
  if (fd) {
    // Rimuovi listener esistente per evitare memory leak
    const oldHandler = fd._draftChangeHandler;
    if (oldHandler) {
      fd.removeEventListener('change', oldHandler);
    }

    // Crea nuovo handler e salvalo per futura rimozione
    const newHandler = () => {
      const b = document.getElementById('draftBadge');
      if (b) b.hidden = !fd.checked;
    };
    fd._draftChangeHandler = newHandler;
    fd.addEventListener('change', newHandler);
  }
  byId("f_raw").value = raw || jsyaml.dump(y);
  fileInfo.textContent = path || "—";
}

/* ====== CREA NUOVO ====== */
byId("newBtn").onclick = () => {
  const today = new Date().toISOString().slice(0,10);
  const y = { date: today, title: "Nuovo item", kind: "content" };
  const slug = kebab(y.title);
  const path = `${FOLDER}/${slug}.${EXT}`;
  CURRENT = { path, sha: null, yaml: y };
  fillForm(y, jsyaml.dump(y), path);
};

/* ====== ELIMINA ====== */
byId("deleteBtn").onclick = async () => {
  if (isDeployLocked()) {
    alert("E' in corso un deploy precedente. Attendi il completamento prima di eliminare.");
    return;
  }
  if (!CURRENT || !CURRENT.path) return alert("Nessun file aperto.");
  if (!confirm(`Eliminare ${CURRENT.path}?`)) return;
  setDeployLock(true, 'Eliminazione in corso...');
  try {
    const sha = await ensureContentSha(CURRENT.path, CURRENT.sha);
    await deleteContent(CURRENT.path, sha);
    saveStatus.textContent = "File eliminato.";
    SELECTED_ITEMS.delete(CURRENT.path);
    CURRENT = null;
    await loadList();
    fillForm({}, "", "-");
    updateSelectionStatus();
    try { await resetSiteCaches(); } catch(_){ }
    updateDeployStatus('Deploy in corso...');
    const ok = await monitorDeployAndReload().catch(()=>false);
    if (ok) {
      updateDeployStatus('Deploy completato');
    } else {
      updateDeployStatus('Deploy non confermato, ricarico...');
      const urlReload = new URL(window.location.href);
      urlReload.searchParams.set('t', String(Date.now()));
      window.location.replace(urlReload.toString());
    }
  } catch (err) {
    alert(err && err.message ? err.message : err);
  } finally {
    setDeployLock(false);
    updateSelectionStatus();
  }
};

/* ====== SALVA (PATCH) ====== */
byId("saveBtn").onclick = async () => {
  if (isDeployLocked()) {
    alert("E' in corso un deploy precedente. Attendi il completamento prima di salvare nuovamente.");
    return;
  }
  if (!TOKEN) { alert("Prima fai login."); return; }

  let lockAcquired = false;
  try {
    setDeployLock(true, 'Preparazione salvataggio...');
    lockAcquired = true;

    // 1) Parti SEMPRE dal YAML attuale (cosi non perdi proprieta non mappate nel form)
    let y = {};
    try {
      const raw = byId("f_raw").value.trim();
      y = raw ? (jsyaml.load(raw) || {}) : {};
    } catch (e) {
      updateDeployStatus('Errore: YAML non valido');
      alert("YAML non valido: " + e.message);
      return;
    }

    // 2) Unisci i campi del form (se valorizzati) senza azzerare chiavi esistenti
    const f_date = byId("f_date").value;
    const f_title = byId("f_title").value;
    const f_slug  = byId("f_slug").value;
    const f_kind  = byId("f_kind").value;
    const f_over  = byId("f_overline").value;
    const f_auth  = byId("f_author").value;
    const f_desc  = byId("f_desc").value;
    const f_id    = byId("f_id").value;
    const f_thumb = byId("f_thumb").value;
    const f_card  = byId("f_card").value;
    const f_tags  = byId("f_tags").value;
    const f_draft = byId("f_draft").checked;
    const f_upd   = byId("f_updated").value;

    if (f_date) y.date = f_date;
    if (f_title) y.title = f_title;
    if (f_kind) y.kind = f_kind;
    if (f_over) y.overline = f_over;
    if (f_auth) y.author = f_auth;
    if (typeof f_desc === 'string') y.desc = f_desc;
    if (f_id) y.id = f_id; else delete y.id;
    if (typeof f_thumb === 'string') y.thumb = f_thumb || undefined;
    if (typeof f_card === 'string') y.card = f_card || undefined;
    const chipTags = readTagsChips();
    const inputTags = (typeof f_tags === 'string')
      ? f_tags.split(',').map(s => s.trim()).filter(Boolean)
      : [];
    const set = new Set([...(chipTags||[]), ...inputTags]);
    y.tags = Array.from(set);
    renderSavedTags(y.tags);
    byId("f_tags").value = "";
    y.draft = !!f_draft;
    if (f_upd) {
      try { y.updated = new Date(f_upd).toISOString(); } catch(_) {}
    }

    // Links from UI
    y.links = readLinksFromUI();

    // 3) Slug: se non dato, genera dal titolo o mantieni l'esistente
    let slug = kebab(f_slug || y.slug || (y.title || ""));
    if (!y.title) {
      updateDeployStatus('Titolo obbligatorio');
      return alert("Titolo obbligatorio");
    }
    if (!slug) {
      updateDeployStatus('Slug obbligatorio');
      return alert("Slug obbligatorio");
    }
    y.slug = slug;

    // 5) Path target: consenti rinomina file se cambi lo slug
    const newPath = `${FOLDER}/${slug}.${EXT}`;
    const isRename = CURRENT && CURRENT.path && CURRENT.path !== newPath;

    // 5.1) Carica eventuali immagini in coda (prima di salvare YAML)
    if (PENDING.thumb) {
      updateDeployStatus('Caricamento thumb...');
      try {
        const res = await uploadAssetFileToPath(PENDING.thumb.file, PENDING.thumb.path);
        byId('f_thumb').value = res.publicUrl;
        y.thumb = res.publicUrl;
        PENDING.thumb = null;
        updateDeployStatus('Thumb caricata');
      } catch(e) {
        updateDeployStatus('Upload thumb fallito');
        alert('Upload thumb fallito: '+(e && e.message || e));
        return;
      }
    }
    if (PENDING.card) {
      updateDeployStatus('Caricamento card...');
      try {
        const res = await uploadAssetFileToPath(PENDING.card.file, PENDING.card.path);
        byId('f_card').value = res.publicUrl;
        y.card = res.publicUrl;
        PENDING.card = null;
        updateDeployStatus('Card caricata');
      } catch(e) {
        updateDeployStatus('Upload card fallito');
        alert('Upload card fallito: '+(e && e.message || e));
        return;
      }
    }
    // 4b) Ora serializza (f_raw riflette l'oggetto finale)
    const content = jsyaml.dump(y);
    byId("f_raw").value = content;

    updateDeployStatus('Salvataggio file in corso...');

    // 6) Salva via GitHub API (create-or-update robusto)
    async function putFileSmart(path, shaMaybe) {
      const url = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}`;
      const mkBody = (sha) => JSON.stringify({
        message: `chore(admin): ${sha ? 'update' : 'create'} ${path}`,
        content: b64.enc(content),
        branch: BRANCH,
        ...(sha ? { sha } : {})
      });

      if (shaMaybe) {
        return gh(url, { method: 'PUT', body: mkBody(shaMaybe) });
      }

      let r = await gh(url, { method: 'PUT', body: mkBody(null) });
      if (r.status === 422) {
        const g = await gh(url);
        if (g.ok) {
          const j = await g.json();
          r = await gh(url, { method: 'PUT', body: mkBody(j.sha) });
        }
      }
      return r;
    }

    if (isRename) {
      let r = await putFileSmart(newPath, null);
      if (!r.ok) {
        updateDeployStatus('Errore salvataggio');
        const t = await r.text().catch(()=>String(r.status));
        alert("Errore creazione nuovo file: " + r.status + " - " + t);
        return;
      }
      const newRes = await r.json();
      if (CURRENT && CURRENT.sha) {
        const delUrl = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${CURRENT.path}`;
        const delBody = { message: `chore(admin): delete ${CURRENT.path}`, sha: CURRENT.sha, branch: BRANCH };
        const del = await gh(delUrl, { method: "DELETE", body: JSON.stringify(delBody) });
        if (!del.ok) {
          const t = await del.text().catch(()=>String(del.status));
          alert("Avviso: nuovo file creato ma non sono riuscito a eliminare il vecchio: " + del.status + " - " + t);
        }
      }
      updateDeployStatus('Salvato (rinominato)');
      CURRENT = { path: newPath, sha: newRes.content.sha, yaml: y };
      fileInfo.textContent = newPath;
    } else {
      const sha = CURRENT ? CURRENT.sha : null;
      let r = await putFileSmart(newPath, sha || null);
      if (!r.ok) {
        updateDeployStatus('Errore salvataggio');
        const t = await r.text().catch(()=>String(r.status));
        alert("Errore salvataggio: " + r.status + " - " + t);
        return;
      }
      const j = await r.json();
      updateDeployStatus('Salvato');
      CURRENT = { path: newPath, sha: j.content.sha, yaml: y };
      fileInfo.textContent = newPath;
    }

    updateDeployStatus('Aggiornamento locale...');
    await loadList();
    try { await resetSiteCaches(); } catch(_){ }

    updateDeployStatus('Deploy in corso...');
    const ok = await monitorDeployAndReload().catch(()=>false);
    if (ok) {
      updateDeployStatus('Deploy completato');
    } else {
      updateDeployStatus('Deploy non confermato, ricarico...');
      const url = new URL(window.location.href);
      url.searchParams.set('t', String(Date.now()));
      window.location.replace(url.toString());
    }
  } finally {
    if (lockAcquired) setDeployLock(false);
  }
};
/* ====== LINKS UI ====== */
function addLinkRow(L={}){
  const row = document.createElement('div');
  row.className = 'row card link-row';
  const opts = [
    {val:'', lab:'(Nessuna)'},
    {val:'btn--yt', lab:'YouTube'},
    {val:'btn--mox', lab:'Moxfield'},
    {val:'btn--archi', lab:'Archidekt'},
    {val:'btn--scry', lab:'Scryfall'},
    {val:'btn--edh', lab:'EDHREC'},
    {val:'btn--teal', lab:'Teal'},
    {val:'btn--base', lab:'Base'},
    {val:'__custom__', lab:'Custom…'}
  ];
  let btnClass = String(L.btn_class||'');
  const effectivePrim = !!(L.primary || /\bprimary\b/.test(btnClass));
  btnClass = btnClass.replace(/\bprimary\b/g,'').replace(/\s{2,}/g,' ').trim();
  const isKnown = opts.some(o => o.val && o.val === btnClass) || btnClass === '';
  const selHtml = '<select class="link-class-select">' + opts.map(o => '<option value="'+o.val+'" '+((!btnClass && o.val==='') || (btnClass===o.val)?'selected':'')+'>'+o.lab+'</option>').join('') + '</select>';
  const inputHtml = '<input type="text" placeholder="Classe custom" class="link-class" value="'+(isKnown?'':escAttr(btnClass))+'" style="'+((btnClass && !isKnown)?'':'display:none')+'">';
  const parsedOrder = parseInt(L.sort_order, 10);
  const sortValue = Number.isFinite(parsedOrder) ? parsedOrder : 0;
  row.innerHTML = `
    <input type="text" placeholder="Label" class="link-label" value="${escAttr(L.label||'')}">
    <input type="text" placeholder="URL" class="link-href" value="${escAttr(L.href||'')}">
    ${selHtml}
    ${inputHtml}
    <input type="number" placeholder="Ordine" class="link-order" value="${sortValue}">
    <label class="muted link-primary-wrap">Primario <input type="checkbox" class="link-primary" ${effectivePrim? 'checked':''}></label>
    <button type="button" class="btn danger link-del">Rimuovi</button>
  `;
  const sel = row.querySelector('.link-class-select');
  const custom = row.querySelector('.link-class');
  if (sel) sel.addEventListener('change', () => {
    if (sel.value === '__custom__') { custom.style.display = ''; custom.focus(); }
    else { if (custom) custom.style.display = 'none'; }
  });
  row.querySelector('.link-del').onclick = () => row.remove();
  byId('linksList').appendChild(row);
}
function readLinksFromUI(){
  const list = byId('linksList');
  const rows = Array.from(list.querySelectorAll('.row.card'));
  const out = [];
  for (const r of rows) {
    const label = r.querySelector('.link-label')?.value?.trim() || '';
    const href  = r.querySelector('.link-href')?.value?.trim() || '';
    let cls   = '';
    const sel  = r.querySelector('.link-class-select');
    const cus  = r.querySelector('.link-class');
    if (sel) {
      if (sel.value === '__custom__') cls = cus?.value?.trim() || '';
      else cls = sel.value || '';
    } else cls = r.querySelector('.link-class')?.value?.trim() || '';
    const ord   = parseInt(r.querySelector('.link-order')?.value || '0', 10) || 0;
    const prim  = !!r.querySelector('.link-primary')?.checked;
    if (!label && !href) continue;
    if (prim && cls && !/\bprimary\b/.test(cls)) cls = (cls + ' primary').trim();
    if (!prim && /\bprimary\b/.test(cls)) cls = cls.replace(/\bprimary\b/g,'').replace(/\s{2,}/g,' ').trim();
    const L = { label, href, btn_class: cls, sort_order: ord, primary: prim };
    if (prim) L.primary = true;
    out.push(L);
  }
  // Mantieni al massimo un "primary" vero
  let sawPrimary = false;
  for (const L of out) {
    if (L.primary && !sawPrimary) { sawPrimary = true; }
    else if (L.primary && sawPrimary) { delete L.primary; }
  }
  return out;
}
byId('addLinkBtn').onclick = () => addLinkRow({ sort_order: 0, primary: false });

function renderSavedTags(arr){
  const el = byId('tagsSaved'); if (!el) return;
  el.innerHTML = '';
  const list = Array.isArray(arr) ? arr : (arr ? [arr] : []);
  list.forEach(t => {
    const s = document.createElement('span');
    s.className = 'chip';
    s.dataset.tag = t;
    s.textContent = String(t) + ' ';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'x';
    btn.setAttribute('aria-label','Rimuovi');
    btn.textContent = 'x';
    btn.onclick = () => { s.remove(); };
    s.appendChild(btn);
    el.appendChild(s);
  });
}

function readTagsChips(){
  const el = byId('tagsSaved'); if (!el) return [];
  return Array.from(el.querySelectorAll('.chip')).map(ch => ch.dataset.tag).filter(Boolean);
}

/* ====== MARKDOWN EDITOR ENHANCEMENTS ====== */
function insertMarkdown(before, after) {
  const textarea = byId('a_body');
  if (!textarea) return;

  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = textarea.value;
  const selected = text.substring(start, end);

  const newText = text.substring(0, start) + before + selected + after + text.substring(end);
  textarea.value = newText;
  textarea.focus();
  textarea.setSelectionRange(start + before.length, start + before.length + selected.length);

  // Update preview if visible
  updateMarkdownPreview();
  updateCharCount();
}

function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

function updateMarkdownPreview() {
  const preview = byId('a_preview');
  const bodyInput = byId('a_body');
  if (!preview || !bodyInput || preview.style.display === 'none') return;

  if (typeof marked !== 'undefined') {
    try {
      // Configure marked per sicurezza: disabilita HTML raw e sanitizza output
      marked.setOptions({
        breaks: true,
        gfm: true,
        headerIds: false,
        mangle: false,
        sanitize: false  // Deprecato in marked v5+, usiamo DOMPurify pattern
      });

      // Parse markdown
      const rawHTML = marked.parse(bodyInput.value || '');

      // Sanitize output manualmente (light sanitization - rimuove script/style/iframe)
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = rawHTML;

      // Rimuovi elementi potenzialmente pericolosi
      const dangerousTags = tempDiv.querySelectorAll('script, style, iframe, object, embed, link[rel="import"]');
      dangerousTags.forEach(el => el.remove());

      // Rimuovi attributi event handler (onclick, onerror, ecc.)
      const allElements = tempDiv.querySelectorAll('*');
      allElements.forEach(el => {
        Array.from(el.attributes).forEach(attr => {
          if (attr.name.startsWith('on') || attr.name === 'href' && attr.value.trim().toLowerCase().startsWith('javascript:')) {
            el.removeAttribute(attr.name);
          }
        });
      });

      preview.innerHTML = tempDiv.innerHTML;
    } catch(e) {
      preview.innerHTML = '<p style="color:red;">Errore rendering Markdown: ' + escHtml(e.message) + '</p>';
    }
  } else {
    preview.innerHTML = '<p style="color:#999;">marked.js non disponibile. Preview disabilitata.</p>';
  }
}

function updateCharCount() {
  const bodyInput = byId('a_body');
  const charEl = byId('a_charCount');
  const readEl = byId('a_readTime');

  if (!bodyInput) return;

  const text = bodyInput.value || '';
  const chars = text.length;
  const words = text.trim().split(/\s+/).filter(Boolean).length;
  const readTime = Math.max(1, Math.ceil(words / 200)); // 200 words/min

  if (charEl) charEl.textContent = chars + ' caratteri, ' + words + ' parole';
  if (readEl) readEl.textContent = '~' + readTime + ' min di lettura';
}

function initMarkdownEditor() {
  const togglePreviewBtn = byId('a_togglePreview');
  const preview = byId('a_preview');
  const bodyInput = byId('a_body');
  const editorWrapper = preview?.parentElement;

  if (togglePreviewBtn && preview && bodyInput && editorWrapper) {
    togglePreviewBtn.onclick = () => {
      const isVisible = preview.style.display !== 'none';
      if (isVisible) {
        preview.style.display = 'none';
        editorWrapper.style.gridTemplateColumns = '1fr';
        togglePreviewBtn.textContent = 'Mostra Preview';
      } else {
        preview.style.display = 'block';
        editorWrapper.style.gridTemplateColumns = '1fr 1fr';
        togglePreviewBtn.textContent = 'Nascondi Preview';
        updateMarkdownPreview();
      }
    };

    bodyInput.addEventListener('input', debounce(() => {
      updateMarkdownPreview();
      updateCharCount();
    }, 300));

    // Initial count
    updateCharCount();
  }
}

/* ====== AUTO-SAVE LOCALE ====== */
let autoSaveTimer = null;
const AUTO_SAVE_KEY_PREFIX = 'article_autosave_';
const AUTO_SAVE_INTERVAL = 30000; // 30 secondi
const AUTO_SAVE_MAX_AGE = 3600000; // 1 ora

function getAutoSaveKey(slug) {
  return AUTO_SAVE_KEY_PREFIX + (slug || 'temp');
}

function saveArticleDraft() {
  if (!ARTICLE_CURRENT || !aBody) return;

  const slug = ARTICLE_CURRENT.slug || 'temp';
  const draft = {
    path: ARTICLE_CURRENT.path,
    slug: slug,
    title: aTitle?.value || '',
    body: aBody.value || '',
    description: aDescription?.value || '',
    tags: aTags?.value || '',
    cover: aCover?.value || '',
    draft: aDraft?.checked || false,
    timestamp: Date.now()
  };

  try {
    localStorage.setItem(getAutoSaveKey(slug), JSON.stringify(draft));
    const status = byId('articleStatus');
    if (status && !status.textContent.includes('salvat')) {
      const oldText = status.textContent;
      status.textContent = '💾 Bozza salvata localmente';
      setTimeout(() => {
        if (status.textContent.includes('Bozza salvata')) {
          status.textContent = oldText;
        }
      }, 2000);
    }
  } catch (e) {
    console.warn('Auto-save fallito:', e);
  }
}

function loadArticleDraft() {
  if (!ARTICLE_CURRENT) return false;

  const slug = ARTICLE_CURRENT.slug || 'temp';

  try {
    const saved = localStorage.getItem(getAutoSaveKey(slug));
    if (!saved) return false;

    const draft = JSON.parse(saved);
    const age = Date.now() - draft.timestamp;

    // Solo se meno di 1 ora fa
    if (age > AUTO_SAVE_MAX_AGE) {
      localStorage.removeItem(getAutoSaveKey(slug));
      return false;
    }

    const minutes = Math.floor(age / 60000);
    const message = `Trovata bozza locale di "${draft.title || slug}" salvata ${minutes} ${minutes === 1 ? 'minuto' : 'minuti'} fa.\n\nRipristinare?`;

    if (confirm(message)) {
      if (aTitle) aTitle.value = draft.title || '';
      if (aBody) aBody.value = draft.body || '';
      if (aDescription) aDescription.value = draft.description || '';
      if (aTags) aTags.value = draft.tags || '';
      if (aCover) aCover.value = draft.cover || '';
      if (aDraft) aDraft.checked = draft.draft;

      updateCharCount();
      updateArticleStatus('✓ Bozza locale ripristinata');
      return true;
    }
  } catch (e) {
    console.warn('Caricamento auto-save fallito:', e);
  }
  return false;
}

function startAutoSave() {
  stopAutoSave();
  autoSaveTimer = setInterval(saveArticleDraft, AUTO_SAVE_INTERVAL);
}

function stopAutoSave() {
  if (autoSaveTimer) {
    clearInterval(autoSaveTimer);
    autoSaveTimer = null;
  }
}

function clearArticleDraft() {
  if (!ARTICLE_CURRENT) return;

  const slug = ARTICLE_CURRENT.slug || 'temp';

  try {
    localStorage.removeItem(getAutoSaveKey(slug));
  } catch (e) {
    console.warn('Impossibile cancellare auto-save:', e);
  }
}

// Cleanup auto-save vecchi (eseguito al boot)
function cleanupOldAutoSaves() {
  try {
    const keys = Object.keys(localStorage);
    const autoSaveKeys = keys.filter(k => k.startsWith(AUTO_SAVE_KEY_PREFIX));

    autoSaveKeys.forEach(key => {
      try {
        const data = localStorage.getItem(key);
        if (!data) return;

        const draft = JSON.parse(data);
        const age = Date.now() - draft.timestamp;

        if (age > AUTO_SAVE_MAX_AGE) {
          localStorage.removeItem(key);
          console.log('Rimossa bozza auto-save scaduta:', key);
        }
      } catch (e) {
        // Corrotta, rimuovi
        localStorage.removeItem(key);
      }
    });
  } catch (e) {
    console.warn('Errore cleanup auto-save:', e);
  }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  const aBody = byId('a_body');

  // Ctrl/Cmd + S to save
  if ((e.ctrlKey || e.metaKey) && e.key === 's') {
    e.preventDefault();
    if (CURRENT_VIEW === 'articles') {
      const saveBtn = byId('saveArticleBtn');
      if (saveBtn && !saveBtn.disabled) saveBtn.click();
    } else if (CURRENT_VIEW === 'items') {
      const saveBtn = byId('saveBtn');
      if (saveBtn && !saveBtn.disabled) saveBtn.click();
    }
  }

  // Markdown shortcuts when focused on article body
  if (document.activeElement === aBody) {
    // Ctrl/Cmd + B for bold
    if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
      e.preventDefault();
      insertMarkdown('**', '**');
    }
    // Ctrl/Cmd + I for italic
    if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
      e.preventDefault();
      insertMarkdown('*', '*');
    }
    // Ctrl/Cmd + K for link
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      insertMarkdown('[', '](url)');
    }
  }
});

/* ====== AVVIO ====== */
(async function boot(){
  // Cleanup lock scaduti e auto-save vecchi
  cleanupExpiredLocks();
  cleanupOldAutoSaves();

  await loadConfig();
  if (TOKEN) {
    const me = await fetchMe().catch(() => null);
    if (me) {
      setWho(me);
      await loadList();
      return;
    }
    try { sessionStorage.removeItem('gh_token'); } catch(_){ }
    try { localStorage.removeItem('gh_token'); } catch(_){ }
    TOKEN = "";
  }
  setWho(null);
})();
</script>
</body>
</html>







